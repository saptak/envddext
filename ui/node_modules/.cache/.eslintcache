[{"/Users/saptak/code/envddext/ui/src/index.tsx":"1","/Users/saptak/code/envddext/ui/src/helper/kubernetes.ts":"2","/Users/saptak/code/envddext/ui/src/AppWithGitHubTemplates.tsx":"3","/Users/saptak/code/envddext/ui/src/services/githubTemplateService.ts":"4","/Users/saptak/code/envddext/ui/src/components/GatewayManagement.tsx":"5","/Users/saptak/code/envddext/ui/src/components/DeploymentStatusMonitor.tsx":"6","/Users/saptak/code/envddext/ui/src/components/HTTPClient.tsx":"7","/Users/saptak/code/envddext/ui/src/components/ProxyManager.tsx":"8","/Users/saptak/code/envddext/ui/src/services/httpClientService.ts":"9","/Users/saptak/code/envddext/ui/src/components/GatewayCreationForm.tsx":"10","/Users/saptak/code/envddext/ui/src/components/LoadBalancerManager.tsx":"11","/Users/saptak/code/envddext/ui/src/components/PodStatusIndicator.tsx":"12","/Users/saptak/code/envddext/ui/src/components/DeploymentTroubleshooter.tsx":"13","/Users/saptak/code/envddext/ui/src/components/GatewayStatusMonitor.tsx":"14","/Users/saptak/code/envddext/ui/src/components/HTTPRequestHistory.tsx":"15","/Users/saptak/code/envddext/ui/src/components/CurlCommandDisplay.tsx":"16","/Users/saptak/code/envddext/ui/src/types/httpClient.ts":"17","/Users/saptak/code/envddext/ui/src/utils/curlGenerator.ts":"18","/Users/saptak/code/envddext/ui/src/components/HTTPResponseDisplay.tsx":"19","/Users/saptak/code/envddext/ui/src/services/kubectlProxyService.ts":"20","/Users/saptak/code/envddext/ui/src/types/gateway.ts":"21","/Users/saptak/code/envddext/ui/src/services/portForwardService.ts":"22","/Users/saptak/code/envddext/ui/src/services/loadBalancerService.ts":"23","/Users/saptak/code/envddext/ui/src/utils/gatewayValidation.ts":"24"},{"size":619,"mtime":1749258551874,"results":"25","hashOfConfig":"26"},{"size":40115,"mtime":1749223855462,"results":"27","hashOfConfig":"26"},{"size":27636,"mtime":1748193548656,"results":"28","hashOfConfig":"26"},{"size":12232,"mtime":1749223923091,"results":"29","hashOfConfig":"26"},{"size":9313,"mtime":1749248373696,"results":"30","hashOfConfig":"26"},{"size":9542,"mtime":1747858889019,"results":"31","hashOfConfig":"26"},{"size":10318,"mtime":1748010502065,"results":"32","hashOfConfig":"26"},{"size":12453,"mtime":1748011272296,"results":"33","hashOfConfig":"26"},{"size":9575,"mtime":1748009233356,"results":"34","hashOfConfig":"26"},{"size":18296,"mtime":1747951506334,"results":"35","hashOfConfig":"26"},{"size":11509,"mtime":1749248764239,"results":"36","hashOfConfig":"26"},{"size":8142,"mtime":1747858812660,"results":"37","hashOfConfig":"26"},{"size":9685,"mtime":1747858851427,"results":"38","hashOfConfig":"26"},{"size":11723,"mtime":1747951551191,"results":"39","hashOfConfig":"26"},{"size":9721,"mtime":1747980065871,"results":"40","hashOfConfig":"26"},{"size":8457,"mtime":1747980101842,"results":"41","hashOfConfig":"26"},{"size":2589,"mtime":1747979857861,"results":"42","hashOfConfig":"26"},{"size":7429,"mtime":1747979941305,"results":"43","hashOfConfig":"26"},{"size":9121,"mtime":1747980024748,"results":"44","hashOfConfig":"26"},{"size":9173,"mtime":1749240504498,"results":"45","hashOfConfig":"26"},{"size":4311,"mtime":1747973400790,"results":"46","hashOfConfig":"26"},{"size":5835,"mtime":1747982428766,"results":"47","hashOfConfig":"26"},{"size":23345,"mtime":1749260991067,"results":"48","hashOfConfig":"26"},{"size":9755,"mtime":1747951446695,"results":"49","hashOfConfig":"26"},{"filePath":"50","messages":"51","suppressedMessages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1w2bxfx",{"filePath":"53","messages":"54","suppressedMessages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56"},{"filePath":"57","messages":"58","suppressedMessages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60"},{"filePath":"61","messages":"62","suppressedMessages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64"},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68"},{"filePath":"69","messages":"70","suppressedMessages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72"},{"filePath":"73","messages":"74","suppressedMessages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76"},{"filePath":"77","messages":"78","suppressedMessages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80"},{"filePath":"81","messages":"82","suppressedMessages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"84","messages":"85","suppressedMessages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","suppressedMessages":"89","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90"},{"filePath":"91","messages":"92","suppressedMessages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"94","messages":"95","suppressedMessages":"96","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"97"},{"filePath":"98","messages":"99","suppressedMessages":"100","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"101"},{"filePath":"102","messages":"103","suppressedMessages":"104","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"105"},{"filePath":"106","messages":"107","suppressedMessages":"108","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109"},{"filePath":"110","messages":"111","suppressedMessages":"112","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"113","messages":"114","suppressedMessages":"115","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"116","messages":"117","suppressedMessages":"118","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119"},{"filePath":"120","messages":"121","suppressedMessages":"122","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"123","messages":"124","suppressedMessages":"125","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"126","messages":"127","suppressedMessages":"128","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"129"},{"filePath":"130","messages":"131","suppressedMessages":"132","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"133","messages":"134","suppressedMessages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/saptak/code/envddext/ui/src/index.tsx",[],[],"/Users/saptak/code/envddext/ui/src/helper/kubernetes.ts",["136"],[],"import { v1 } from \"@docker/extension-api-client-types\";\nimport { Gateway, GatewayFormData, GatewayStatusInfo, GatewayClass } from \"../types/gateway\";\nimport { HTTPRoute, HTTPRouteFormData, HTTPRouteStatusInfo, HTTPRouteValidationResult, ValidationError } from '../types/httproute';\nimport yaml from 'js-yaml';\n\n// Backend API response type\ninterface APIResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\n// Helper function to call backend API\nconst callBackendAPI = async <T = any>(\n  ddClient: v1.DockerDesktopClient,\n  endpoint: string,\n  method: 'GET' | 'POST' = 'GET',\n  data?: any\n): Promise<APIResponse<T>> => {\n  try {\n    let response;\n    if (method === 'POST') {\n      response = await ddClient.extension.vm?.service?.post(endpoint, data);\n    } else {\n      response = await ddClient.extension.vm?.service?.get(endpoint);\n    }\n    return response as APIResponse<T>;\n  } catch (error: any) {\n    console.error(`Backend API call failed (${method} ${endpoint}):`, error);\n    return {\n      success: false,\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\nexport const DockerDesktop = \"docker-desktop\";\nexport const CurrentExtensionContext = \"currentExtensionContext\";\nexport const IsK8sEnabled = \"isK8sEnabled\";\n\nexport const listHostContexts = async (ddClient: v1.DockerDesktopClient) => {\n  const response = await callBackendAPI<string>(ddClient, '/kubectl', 'POST', {\n    args: [\"config\", \"view\", \"-o\", \"jsonpath='{.contexts}'\"]\n  });\n  \n  if (response.success) {\n    return response.data;\n  } else {\n    console.log(response.error);\n    return response.error;\n  }\n};\n\nexport const setDockerDesktopContext = async (\n  ddClient: v1.DockerDesktopClient\n) => {\n  const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n    \"config\",\n    \"use-context\",\n    \"docker-desktop\",\n  ]);\n  console.log(output);\n  if (output?.stderr) {\n    return output.stderr;\n  }\n  return output?.stdout;\n};\n\nexport const getCurrentHostContext = async (\n  ddClient: v1.DockerDesktopClient\n) => {\n  const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n    \"config\",\n    \"view\",\n    \"-o\",\n    \"jsonpath='{.current-context}'\",\n  ]);\n  console.log(output);\n  if (output?.stderr) {\n    return output.stderr;\n  }\n  return output?.stdout;\n};\n\nexport const checkK8sConnection = async (ddClient: v1.DockerDesktopClient) => {\n  try {\n    let output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"cluster-info\",\n      \"--request-timeout\",\n      \"2s\",\n    ]);\n    console.log(output);\n    if (output?.stderr) {\n      console.log(output.stderr);\n      return \"false\";\n    }\n    return \"true\";\n  } catch (e: any) {\n    console.log(\"[checkK8sConnection] error : \", e);\n    return \"false\";\n  }\n};\n\nexport const listNamespaces = async (ddClient: v1.DockerDesktopClient) => {\n  const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n    \"get\",\n    \"namespaces\",\n    \"--no-headers\",\n    \"-o\",\n    'custom-columns=\":metadata.name\"',\n    \"--context\",\n    \"docker-desktop\",\n  ]);\n  console.log(output);\n  if (output?.stderr) {\n    return output.stderr;\n  }\n  return output?.stdout;\n};\n\nexport const listEnvoyGateways = async (ddClient: v1.DockerDesktopClient) => {\n  const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n    \"get\",\n    \"gateways.gateway.networking.k8s.io\",\n    \"-A\",\n    \"-o\",\n    \"json\"\n  ]);\n  if (output?.stderr && !output.stderr.includes(\"not found\")) {\n    return { error: output.stderr };\n  }\n  try {\n    return JSON.parse(output?.stdout || '{\"items\":[]}');\n  } catch (e) {\n    return { error: 'Failed to parse gateways JSON' };\n  }\n};\n\nexport const listEnvoyHTTPRoutes = async (ddClient: v1.DockerDesktopClient) => {\n  const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n    \"get\",\n    \"httproutes.gateway.networking.k8s.io\",\n    \"-A\",\n    \"-o\",\n    \"json\"\n  ]);\n  if (output?.stderr && !output.stderr.includes(\"not found\")) {\n    return { error: output.stderr };\n  }\n  try {\n    return JSON.parse(output?.stdout || '{\"items\":[]}');\n  } catch (e) {\n    return { error: 'Failed to parse httproutes JSON' };\n  }\n};\n\nexport const installEnvoyGateway = async (ddClient: v1.DockerDesktopClient, version: string = \"latest\") => {\n  try {\n    // First, try to uninstall any existing Envoy Gateway installation\n    try {\n      console.log(\"Attempting to uninstall any existing Envoy Gateway installation...\");\n      const uninstallOutput = await ddClient.extension.host?.cli.exec(\"helm\", [\n        \"uninstall\",\n        \"envoy-gateway\"\n      ]);\n      console.log(\"Helm uninstall output:\", uninstallOutput);\n    } catch (uninstallError) {\n      // Ignore uninstall errors - the release might not exist\n      console.log(\"Uninstall error (likely release not found, which is fine):\", uninstallError);\n    }\n\n    // Install Envoy Gateway directly from OCI registry\n    console.log(\"Installing Envoy Gateway from OCI registry...\");\n    const installOutput = await ddClient.extension.host?.cli.exec(\"helm\", [\n      \"install\",\n      \"envoy-gateway\",\n      \"oci://docker.io/envoyproxy/gateway-helm\",\n      \"--version\",\n      version === \"latest\" ? \"v0.0.0-latest\" : version,\n      \"--namespace\",\n      \"envoy-gateway-system\",\n      \"--create-namespace\",\n      \"--wait\",\n      \"--debug\"\n    ]);\n    console.log(\"Helm install output:\", installOutput);\n\n    if (installOutput?.stderr && installOutput.stderr.includes('Error: ') &&\n        !installOutput.stderr.includes('already exists')) {\n      return { error: installOutput.stderr };\n    }\n\n    // Wait for a few seconds to allow CRDs to be properly registered\n    console.log(\"Waiting for CRDs to be properly registered...\");\n    await new Promise(resolve => setTimeout(resolve, 5000));\n\n    // Verify CRDs are installed\n    let crdCheck = await checkEnvoyGatewayCRDs(ddClient);\n\n    // If first check fails, wait a bit longer and try again\n    if (!crdCheck) {\n      console.log(\"First CRD check failed, waiting longer...\");\n      await new Promise(resolve => setTimeout(resolve, 10000));\n      crdCheck = await checkEnvoyGatewayCRDs(ddClient);\n    }\n\n    if (!crdCheck) {\n      return { error: \"Failed to verify Envoy Gateway CRDs installation\" };\n    }\n\n    return { success: true };\n  } catch (e: any) {\n    console.error(\"Error during Envoy Gateway installation:\", e);\n    return { error: typeof e === 'string' ? e : JSON.stringify(e, null, 2) };\n  }\n};\n\n/**\n * Get detailed status of a deployment\n * @param ddClient Docker Desktop client\n * @param namespace Namespace of the deployment\n * @param name Name of the deployment\n * @returns Detailed deployment status information\n */\nexport const getDetailedDeploymentStatus = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string,\n  name: string\n): Promise<{\n  status: 'ready' | 'pending' | 'failed' | 'not_found';\n  readyReplicas: number;\n  desiredReplicas: number;\n  message?: string;\n  deployment?: any;\n  age?: string;\n  conditions?: any[];\n}> => {\n  try {\n    // Get deployment details\n    const deployOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"deployment\",\n      \"-n\",\n      namespace,\n      name,\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!deployOutput?.stdout || deployOutput.stdout.trim() === \"\") {\n      return {\n        status: 'not_found',\n        readyReplicas: 0,\n        desiredReplicas: 0,\n        message: `Deployment '${name}' not found in namespace '${namespace}'`\n      };\n    }\n\n    const deployment = JSON.parse(deployOutput.stdout);\n    const readyReplicas = deployment.status?.readyReplicas || 0;\n    const desiredReplicas = deployment.spec?.replicas || 0;\n    const conditions = deployment.status?.conditions || [];\n\n    // Calculate age\n    const creationTimestamp = new Date(deployment.metadata.creationTimestamp);\n    const now = new Date();\n    const ageMs = now.getTime() - creationTimestamp.getTime();\n    const ageMinutes = Math.floor(ageMs / (1000 * 60));\n    const ageHours = Math.floor(ageMinutes / 60);\n    const ageDays = Math.floor(ageHours / 24);\n\n    let age = '';\n    if (ageDays > 0) {\n      age = `${ageDays}d`;\n    } else if (ageHours > 0) {\n      age = `${ageHours}h`;\n    } else {\n      age = `${ageMinutes}m`;\n    }\n\n    // Determine status\n    let status: 'ready' | 'pending' | 'failed';\n    let message = '';\n\n    if (readyReplicas < desiredReplicas) {\n      status = 'pending';\n      message = `${readyReplicas}/${desiredReplicas} replicas ready`;\n    } else {\n      // Check conditions for any issues\n      const failedCondition = conditions.find((c: any) => c.status !== 'True' && c.type !== 'Progressing');\n      if (failedCondition) {\n        status = 'failed';\n        message = `${failedCondition.reason}: ${failedCondition.message}`;\n      } else {\n        status = 'ready';\n        message = `All ${readyReplicas} replicas are ready`;\n      }\n    }\n\n    return {\n      status,\n      readyReplicas,\n      desiredReplicas,\n      message,\n      deployment,\n      age,\n      conditions\n    };\n  } catch (error: any) {\n    console.error(\"Error getting detailed deployment status:\", error);\n    return {\n      status: 'failed',\n      readyReplicas: 0,\n      desiredReplicas: 0,\n      message: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Get detailed information about pods\n * @param ddClient Docker Desktop client\n * @param namespace Namespace of the pods\n * @param selector Label selector for the pods\n * @returns Array of pod details with events\n */\nexport const getPodDetails = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string,\n  selector: string\n): Promise<any[]> => {\n  try {\n    // Get pods\n    const podsOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"pods\",\n      \"-n\",\n      namespace,\n      \"-l\",\n      selector,\n      \"-o\",\n      \"json\"\n    ]);\n\n    if (!podsOutput?.stdout || podsOutput.stdout.trim() === \"\") {\n      return [];\n    }\n\n    const podsJson = JSON.parse(podsOutput.stdout);\n    const pods = podsJson.items || [];\n\n    // Get events for each pod\n    for (const pod of pods) {\n      const podName = pod.metadata.name;\n      const eventsOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n        \"get\",\n        \"events\",\n        \"--field-selector\",\n        `involvedObject.name=${podName}`,\n        \"-n\",\n        namespace,\n        \"-o\",\n        \"json\"\n      ]);\n\n      if (eventsOutput?.stdout && eventsOutput.stdout.trim() !== \"\") {\n        const eventsJson = JSON.parse(eventsOutput.stdout);\n        pod.events = eventsJson.items || [];\n      } else {\n        pod.events = [];\n      }\n    }\n\n    return pods;\n  } catch (error: any) {\n    console.error(\"Error getting pod details:\", error);\n    return [];\n  }\n};\n\n/**\n * Get service endpoints\n * @param ddClient Docker Desktop client\n * @param namespace Namespace of the service\n * @param name Name of the service\n * @returns Service endpoint information\n */\nexport const getServiceEndpoints = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string,\n  name: string\n): Promise<{\n  found: boolean;\n  endpoints?: string[];\n  ports?: any[];\n  message?: string;\n}> => {\n  try {\n    // Get service details\n    const svcOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"service\",\n      \"-n\",\n      namespace,\n      name,\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!svcOutput?.stdout || svcOutput.stdout.trim() === \"\") {\n      return {\n        found: false,\n        message: `Service '${name}' not found in namespace '${namespace}'`\n      };\n    }\n\n    const service = JSON.parse(svcOutput.stdout);\n    const ports = service.spec?.ports || [];\n\n    // Get endpoints\n    const endpointsOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"endpoints\",\n      \"-n\",\n      namespace,\n      name,\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    let endpoints: string[] = [];\n\n    if (endpointsOutput?.stdout && endpointsOutput.stdout.trim() !== \"\") {\n      const endpointsJson = JSON.parse(endpointsOutput.stdout);\n      const subsets = endpointsJson.subsets || [];\n\n      for (const subset of subsets) {\n        const addresses = subset.addresses || [];\n        const ports = subset.ports || [];\n\n        for (const address of addresses) {\n          for (const port of ports) {\n            endpoints.push(`${address.ip}:${port.port}`);\n          }\n        }\n      }\n    }\n\n    return {\n      found: true,\n      endpoints,\n      ports\n    };\n  } catch (error: any) {\n    console.error(\"Error getting service endpoints:\", error);\n    return {\n      found: false,\n      message: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\nexport const checkEnvoyGatewayCRDs = async (ddClient: v1.DockerDesktopClient): Promise<boolean> => {\n  try {\n    // First, check if the namespace exists\n    const nsOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"namespace\",\n      \"envoy-gateway-system\",\n      \"--no-headers\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!nsOutput?.stdout || nsOutput.stdout.trim() === \"\") {\n      console.log(\"Envoy Gateway namespace not found\");\n      return false;\n    }\n\n    // Check if the deployment is running\n    const deployOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"deployment\",\n      \"-n\",\n      \"envoy-gateway-system\",\n      \"envoy-gateway\",\n      \"--no-headers\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!deployOutput?.stdout || deployOutput.stdout.trim() === \"\") {\n      console.log(\"Envoy Gateway deployment not found\");\n      return false;\n    }\n\n    // Check for Gateway API CRDs\n    const crdOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"crd\",\n      \"gateways.gateway.networking.k8s.io\",\n      \"httproutes.gateway.networking.k8s.io\",\n      \"--no-headers\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!crdOutput?.stdout || crdOutput.stdout.trim() === \"\") {\n      console.log(\"Gateway API CRDs not found\");\n      return false;\n    }\n\n    // Check for Envoy Gateway specific CRDs\n    const egCrdOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"crd\",\n      \"envoyproxies.gateway.envoyproxy.io\",\n      \"--no-headers\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!egCrdOutput?.stdout || egCrdOutput.stdout.trim() === \"\") {\n      console.log(\"Envoy Gateway specific CRDs not found\");\n      return false;\n    }\n\n    // All checks passed\n    return true;\n  } catch (e) {\n    console.error(\"Error checking Envoy Gateway installation:\", e);\n    return false;\n  }\n};\n\n/**\n * List available GatewayClasses\n * @param ddClient Docker Desktop client\n * @returns Array of GatewayClass objects\n */\nexport const listGatewayClasses = async (ddClient: v1.DockerDesktopClient): Promise<GatewayClass[]> => {\n  try {\n    const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"gatewayclasses.gateway.networking.k8s.io\",\n      \"-o\",\n      \"json\"\n    ]);\n\n    if (output?.stderr && !output.stderr.includes(\"not found\")) {\n      console.error(\"Error listing GatewayClasses:\", output.stderr);\n      return [];\n    }\n\n    if (!output?.stdout || output.stdout.trim() === \"\") {\n      return [];\n    }\n\n    const result = JSON.parse(output.stdout);\n    return result.items || [];\n  } catch (error: any) {\n    console.error(\"Error listing GatewayClasses:\", error);\n    return [];\n  }\n};\n\n/**\n * Create a Gateway resource\n * @param ddClient Docker Desktop client\n * @param gatewayData Gateway form data\n * @returns Success/error result\n */\nexport const createGateway = async (\n  ddClient: v1.DockerDesktopClient,\n  gatewayData: GatewayFormData\n): Promise<{ success: boolean; error?: string; gateway?: Gateway }> => {\n  const response = await callBackendAPI<string>(ddClient, '/create-gateway', 'POST', gatewayData);\n  \n  if (response.success) {\n    return { success: true };\n  } else {\n    return { success: false, error: response.error };\n  }\n};\n\n/**\n * Get detailed Gateway status information\n * @param ddClient Docker Desktop client\n * @param namespace Namespace of the Gateway\n * @param name Name of the Gateway\n * @returns Detailed Gateway status information\n */\nexport const getGatewayStatus = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string,\n  name: string\n): Promise<GatewayStatusInfo> => {\n  try {\n    // Get Gateway details\n    const gatewayOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"gateway\",\n      \"-n\",\n      namespace,\n      name,\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!gatewayOutput?.stdout || gatewayOutput.stdout.trim() === \"\") {\n      return {\n        name,\n        namespace,\n        status: 'unknown',\n        message: `Gateway '${name}' not found in namespace '${namespace}'`\n      };\n    }\n\n    const gateway: Gateway = JSON.parse(gatewayOutput.stdout);\n    const conditions = gateway.status?.conditions || [];\n    const listeners = gateway.status?.listeners || [];\n    const addresses = gateway.status?.addresses || [];\n\n    // Calculate age\n    let age = '';\n    if (gateway.metadata.creationTimestamp) {\n      const creationTime = new Date(gateway.metadata.creationTimestamp);\n      const now = new Date();\n      const ageMs = now.getTime() - creationTime.getTime();\n      const ageMinutes = Math.floor(ageMs / (1000 * 60));\n      const ageHours = Math.floor(ageMinutes / 60);\n      const ageDays = Math.floor(ageHours / 24);\n\n      if (ageDays > 0) {\n        age = `${ageDays}d`;\n      } else if (ageHours > 0) {\n        age = `${ageHours}h`;\n      } else {\n        age = `${ageMinutes}m`;\n      }\n    }\n\n    // Determine overall status\n    let status: 'ready' | 'pending' | 'failed' | 'unknown' = 'unknown';\n    let message = '';\n\n    // Check for Programmed condition\n    const programmedCondition = conditions.find(c => c.type === 'Programmed');\n    if (programmedCondition) {\n      if (programmedCondition.status === 'True') {\n        status = 'ready';\n        message = 'Gateway is programmed and ready';\n      } else if (programmedCondition.status === 'False') {\n        status = 'failed';\n        message = `Gateway programming failed: ${programmedCondition.message}`;\n      } else {\n        status = 'pending';\n        message = `Gateway programming pending: ${programmedCondition.message}`;\n      }\n    } else {\n      status = 'pending';\n      message = 'Gateway status unknown - waiting for controller';\n    }\n\n    // Process listener status\n    const listenerStatus = listeners.map(listener => {\n      const listenerConditions = listener.conditions || [];\n      const programmedCondition = listenerConditions.find(c => c.type === 'Programmed');\n\n      let listenerStatus: 'ready' | 'pending' | 'failed' = 'pending';\n      let listenerMessage = '';\n\n      if (programmedCondition) {\n        if (programmedCondition.status === 'True') {\n          listenerStatus = 'ready';\n          listenerMessage = 'Listener is ready';\n        } else {\n          listenerStatus = 'failed';\n          listenerMessage = programmedCondition.message;\n        }\n      }\n\n      return {\n        name: listener.name,\n        status: listenerStatus,\n        attachedRoutes: listener.attachedRoutes,\n        message: listenerMessage\n      };\n    });\n\n    return {\n      name,\n      namespace,\n      status,\n      message,\n      addresses: addresses.map(addr => addr.value),\n      listeners: listenerStatus,\n      conditions,\n      age\n    };\n  } catch (error: any) {\n    console.error(\"Error getting Gateway status:\", error);\n    return {\n      name,\n      namespace,\n      status: 'failed',\n      message: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Delete a Gateway resource\n * @param ddClient Docker Desktop client\n * @param namespace Namespace of the Gateway\n * @param name Name of the Gateway\n * @returns Success/error result\n */\nexport const deleteGateway = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string,\n  name: string\n): Promise<{ success: boolean; error?: string }> => {\n  try {\n    const deleteOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"delete\",\n      \"gateway\",\n      \"-n\",\n      namespace,\n      name,\n      \"--ignore-not-found\"\n    ]);\n\n    if (deleteOutput?.stderr && deleteOutput.stderr.includes('Error:')) {\n      return {\n        success: false,\n        error: deleteOutput.stderr\n      };\n    }\n\n    return { success: true };\n  } catch (error: any) {\n    console.error(\"Error deleting Gateway:\", error);\n    return {\n      success: false,\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * List available namespaces\n * @param ddClient Docker Desktop client\n * @returns Array of namespace names\n */\nexport const listNamespaceNames = async (ddClient: v1.DockerDesktopClient): Promise<string[]> => {\n  try {\n    const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"namespaces\",\n      \"-o\",\n      \"jsonpath={.items[*].metadata.name}\"\n    ]);\n\n    if (output?.stderr) {\n      console.error(\"Error listing namespaces:\", output.stderr);\n      return ['default'];\n    }\n\n    if (!output?.stdout || output.stdout.trim() === \"\") {\n      return ['default'];\n    }\n\n    return output.stdout.trim().split(/\\s+/).filter(ns => ns.length > 0);\n  } catch (error: any) {\n    console.error(\"Error listing namespaces:\", error);\n    return ['default'];\n  }\n};\n\n// ============================================================================\n// HTTPRoute Management Functions\n// ============================================================================\n\n/**\n * Create an HTTPRoute resource\n * @param ddClient Docker Desktop client\n * @param routeData HTTPRoute form data\n * @returns Success/error result with created HTTPRoute\n */\nexport const createHTTPRoute = async (\n  ddClient: v1.DockerDesktopClient,\n  routeData: HTTPRouteFormData\n): Promise<{ success: boolean; error?: string; httpRoute?: HTTPRoute }> => {\n  // Validate the form data first\n  const validation = validateHTTPRouteConfiguration(routeData);\n  if (!validation.isValid) {\n    return {\n      success: false,\n      error: `Validation failed: ${validation.errors.map(e => e.message).join(', ')}`\n    };\n  }\n\n  const response = await callBackendAPI<string>(ddClient, '/create-httproute', 'POST', routeData);\n  \n  if (response.success) {\n    return { success: true };\n  } else {\n    return { success: false, error: response.error };\n  }\n};\n\n/**\n * List HTTPRoutes with optional filtering\n * @param ddClient Docker Desktop client\n * @param namespace Optional namespace filter\n * @returns List of HTTPRoutes\n */\nexport const listHTTPRoutes = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace?: string\n): Promise<{ items: HTTPRoute[]; error?: string }> => {\n  try {\n    const args = [\n      \"get\",\n      \"httproutes.gateway.networking.k8s.io\",\n      \"-o\",\n      \"json\"\n    ];\n\n    if (namespace) {\n      args.splice(2, 0, \"-n\", namespace);\n    } else {\n      args.splice(2, 0, \"-A\");\n    }\n\n    const output = await ddClient.extension.host?.cli.exec(\"kubectl\", args);\n\n    if (output?.stderr && !output.stderr.includes(\"not found\")) {\n      return { items: [], error: output.stderr };\n    }\n\n    try {\n      const result = JSON.parse(output?.stdout || '{\"items\":[]}');\n      return { items: result.items || [] };\n    } catch (e) {\n      return { items: [], error: 'Failed to parse HTTPRoutes JSON' };\n    }\n  } catch (error: any) {\n    console.error(\"Error listing HTTPRoutes:\", error);\n    return {\n      items: [],\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Get detailed HTTPRoute status information\n * @param ddClient Docker Desktop client\n * @param namespace Namespace of the HTTPRoute\n * @param name Name of the HTTPRoute\n * @returns Detailed HTTPRoute status information\n */\nexport const getHTTPRouteStatus = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string,\n  name: string\n): Promise<HTTPRouteStatusInfo> => {\n  try {\n    // Get HTTPRoute details\n    const routeOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"httproute\",\n      \"-n\",\n      namespace,\n      name,\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!routeOutput?.stdout || routeOutput.stdout.trim() === \"\") {\n      return {\n        name,\n        namespace,\n        status: 'unknown',\n        message: `HTTPRoute '${name}' not found in namespace '${namespace}'`\n      };\n    }\n\n    const httpRoute: HTTPRoute = JSON.parse(routeOutput.stdout);\n    const conditions = httpRoute.status?.parents?.[0]?.conditions || [];\n\n    // Calculate age\n    let age = '';\n    if (httpRoute.metadata.creationTimestamp) {\n      const creationTime = new Date(httpRoute.metadata.creationTimestamp);\n      const now = new Date();\n      const ageMs = now.getTime() - creationTime.getTime();\n      const ageMinutes = Math.floor(ageMs / (1000 * 60));\n      const ageHours = Math.floor(ageMinutes / 60);\n      const ageDays = Math.floor(ageHours / 24);\n\n      if (ageDays > 0) {\n        age = `${ageDays}d`;\n      } else if (ageHours > 0) {\n        age = `${ageHours}h`;\n      } else {\n        age = `${ageMinutes}m`;\n      }\n    }\n\n    // Determine overall status\n    let status: 'ready' | 'pending' | 'failed' | 'unknown' = 'unknown';\n    let message = '';\n\n    // Check for Accepted condition\n    const acceptedCondition = conditions.find(c => c.type === 'Accepted');\n    if (acceptedCondition) {\n      if (acceptedCondition.status === 'True') {\n        status = 'ready';\n        message = 'HTTPRoute is accepted and ready';\n      } else if (acceptedCondition.status === 'False') {\n        status = 'failed';\n        message = `HTTPRoute not accepted: ${acceptedCondition.message}`;\n      } else {\n        status = 'pending';\n        message = `HTTPRoute acceptance pending: ${acceptedCondition.message}`;\n      }\n    } else {\n      status = 'pending';\n      message = 'HTTPRoute status unknown - waiting for controller';\n    }\n\n    // Process parent Gateway status\n    const parentGateways = httpRoute.status?.parents?.map(parent => ({\n      name: parent.parentRef.name,\n      namespace: parent.parentRef.namespace || namespace,\n      status: parent.conditions.find(c => c.type === 'Accepted')?.status === 'True' ? 'accepted' as const :\n              parent.conditions.find(c => c.type === 'Accepted')?.status === 'False' ? 'failed' as const : 'pending' as const,\n      message: parent.conditions.find(c => c.type === 'Accepted')?.message\n    })) || [];\n\n    // Check backend services status\n    const backendServices: Array<{\n      name: string;\n      namespace: string;\n      status: 'available' | 'unavailable' | 'unknown';\n      endpoints?: number;\n    }> = [];\n\n    for (const rule of httpRoute.spec.rules || []) {\n      for (const backend of rule.backendRefs || []) {\n        const serviceNamespace = backend.namespace || namespace;\n        const serviceStatus = await getServiceEndpoints(ddClient, serviceNamespace, backend.name);\n\n        backendServices.push({\n          name: backend.name,\n          namespace: serviceNamespace,\n          status: serviceStatus.found ? 'available' : 'unavailable',\n          endpoints: serviceStatus.endpoints?.length || 0\n        });\n      }\n    }\n\n    return {\n      name,\n      namespace,\n      status,\n      message,\n      parentGateways,\n      backendServices,\n      conditions,\n      age\n    };\n  } catch (error: any) {\n    console.error(\"Error getting HTTPRoute status:\", error);\n    return {\n      name,\n      namespace,\n      status: 'failed',\n      message: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Delete an HTTPRoute resource\n * @param ddClient Docker Desktop client\n * @param namespace Namespace of the HTTPRoute\n * @param name Name of the HTTPRoute\n * @returns Success/error result\n */\nexport const deleteHTTPRoute = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string,\n  name: string\n): Promise<{ success: boolean; error?: string }> => {\n  try {\n    const deleteOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"delete\",\n      \"httproute\",\n      \"-n\",\n      namespace,\n      name,\n      \"--ignore-not-found\"\n    ]);\n\n    if (deleteOutput?.stderr && deleteOutput.stderr.includes('Error:')) {\n      return {\n        success: false,\n        error: deleteOutput.stderr\n      };\n    }\n\n    return { success: true };\n  } catch (error: any) {\n    console.error(\"Error deleting HTTPRoute:\", error);\n    return {\n      success: false,\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Validate HTTPRoute configuration\n * @param routeData HTTPRoute form data\n * @returns Validation result with errors\n */\nexport const validateHTTPRouteConfiguration = (routeData: HTTPRouteFormData): HTTPRouteValidationResult => {\n  const errors: ValidationError[] = [];\n\n  // Validate basic fields\n  if (!routeData.name.trim()) {\n    errors.push({ field: 'name', message: 'HTTPRoute name is required' });\n  } else if (!/^[a-z0-9]([-a-z0-9]*[a-z0-9])?$/.test(routeData.name)) {\n    errors.push({ field: 'name', message: 'HTTPRoute name must be a valid DNS subdomain' });\n  }\n\n  if (!routeData.namespace.trim()) {\n    errors.push({ field: 'namespace', message: 'Namespace is required' });\n  }\n\n  if (!routeData.parentGateway.trim()) {\n    errors.push({ field: 'parentGateway', message: 'Parent Gateway is required' });\n  }\n\n  // Validate hostnames\n  routeData.hostnames.forEach((hostname, index) => {\n    if (hostname && !/^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/.test(hostname)) {\n      errors.push({ field: `hostnames[${index}]`, message: 'Invalid hostname format' });\n    }\n  });\n\n  // Validate rules\n  if (routeData.rules.length === 0) {\n    errors.push({ field: 'rules', message: 'At least one rule is required' });\n  }\n\n  routeData.rules.forEach((rule, ruleIndex) => {\n    // Validate matches\n    if (rule.matches.length === 0) {\n      errors.push({ field: `rules[${ruleIndex}].matches`, message: 'At least one match is required per rule' });\n    }\n\n    rule.matches.forEach((match, matchIndex) => {\n      if (!match.pathValue.trim()) {\n        errors.push({ field: `rules[${ruleIndex}].matches[${matchIndex}].pathValue`, message: 'Path value is required' });\n      } else if (!match.pathValue.startsWith('/')) {\n        errors.push({ field: `rules[${ruleIndex}].matches[${matchIndex}].pathValue`, message: 'Path must start with /' });\n      }\n\n      // Validate headers\n      match.headers.forEach((header, headerIndex) => {\n        if (!header.name.trim()) {\n          errors.push({ field: `rules[${ruleIndex}].matches[${matchIndex}].headers[${headerIndex}].name`, message: 'Header name is required' });\n        }\n        if (!header.value.trim()) {\n          errors.push({ field: `rules[${ruleIndex}].matches[${matchIndex}].headers[${headerIndex}].value`, message: 'Header value is required' });\n        }\n      });\n\n      // Validate query parameters\n      match.queryParams.forEach((param, paramIndex) => {\n        if (!param.name.trim()) {\n          errors.push({ field: `rules[${ruleIndex}].matches[${matchIndex}].queryParams[${paramIndex}].name`, message: 'Query parameter name is required' });\n        }\n        if (!param.value.trim()) {\n          errors.push({ field: `rules[${ruleIndex}].matches[${matchIndex}].queryParams[${paramIndex}].value`, message: 'Query parameter value is required' });\n        }\n      });\n    });\n\n    // Validate backend refs\n    if (rule.backendRefs.length === 0) {\n      errors.push({ field: `rules[${ruleIndex}].backendRefs`, message: 'At least one backend reference is required per rule' });\n    }\n\n    rule.backendRefs.forEach((backend, backendIndex) => {\n      if (!backend.name.trim()) {\n        errors.push({ field: `rules[${ruleIndex}].backendRefs[${backendIndex}].name`, message: 'Backend service name is required' });\n      }\n\n      if (backend.port <= 0 || backend.port > 65535) {\n        errors.push({ field: `rules[${ruleIndex}].backendRefs[${backendIndex}].port`, message: 'Port must be between 1 and 65535' });\n      }\n\n      if (backend.weight < 0 || backend.weight > 1000000) {\n        errors.push({ field: `rules[${ruleIndex}].backendRefs[${backendIndex}].weight`, message: 'Weight must be between 0 and 1000000' });\n      }\n    });\n\n    // Validate timeouts\n    if (rule.requestTimeout && !/^\\d+(\\.\\d+)?(ms|s|m|h)$/.test(rule.requestTimeout)) {\n      errors.push({ field: `rules[${ruleIndex}].requestTimeout`, message: 'Invalid timeout format (use: 30s, 5m, 1h, etc.)' });\n    }\n\n    if (rule.backendRequestTimeout && !/^\\d+(\\.\\d+)?(ms|s|m|h)$/.test(rule.backendRequestTimeout)) {\n      errors.push({ field: `rules[${ruleIndex}].backendRequestTimeout`, message: 'Invalid timeout format (use: 30s, 5m, 1h, etc.)' });\n    }\n\n    // Validate that backendRequest timeout is not greater than request timeout\n    if (rule.requestTimeout && rule.backendRequestTimeout) {\n      const requestTimeoutMs = parseDuration(rule.requestTimeout);\n      const backendTimeoutMs = parseDuration(rule.backendRequestTimeout);\n\n      if (requestTimeoutMs > 0 && backendTimeoutMs > 0 && backendTimeoutMs > requestTimeoutMs) {\n        errors.push({\n          field: `rules[${ruleIndex}].backendRequestTimeout`,\n          message: 'Backend request timeout cannot be greater than request timeout'\n        });\n      }\n    }\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n};\n\n/**\n * Parse duration string to milliseconds (simplified)\n * @param duration Duration string like \"30s\", \"5m\", \"1h\"\n * @returns Duration in milliseconds, or -1 if invalid\n */\nconst parseDuration = (duration: string): number => {\n  const match = duration.match(/^(\\d+(?:\\.\\d+)?)(ms|s|m|h)$/);\n  if (!match) return -1;\n\n  const value = parseFloat(match[1]);\n  const unit = match[2];\n\n  switch (unit) {\n    case 'ms': return value;\n    case 's': return value * 1000;\n    case 'm': return value * 60 * 1000;\n    case 'h': return value * 60 * 60 * 1000;\n    default: return -1;\n  }\n};\n\n/**\n * Get available Gateways for HTTPRoute parentRef selection\n * @param ddClient Docker Desktop client\n * @param namespace Optional namespace filter\n * @returns List of available Gateways\n */\nexport const getAvailableGateways = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace?: string\n): Promise<{ items: Array<{ name: string; namespace: string; listeners: string[] }>; error?: string }> => {\n  try {\n    const gatewayResult = await listEnvoyGateways(ddClient);\n\n    if (gatewayResult.error) {\n      return { items: [], error: gatewayResult.error };\n    }\n\n    const gateways = gatewayResult.items || [];\n    const availableGateways = gateways\n      .filter((gw: Gateway) => !namespace || gw.metadata.namespace === namespace)\n      .map((gw: Gateway) => ({\n        name: gw.metadata.name,\n        namespace: gw.metadata.namespace,\n        listeners: gw.spec.listeners.map(l => `${l.name} (${l.protocol}:${l.port})`)\n      }));\n\n    return { items: availableGateways };\n  } catch (error: any) {\n    console.error(\"Error getting available Gateways:\", error);\n    return {\n      items: [],\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Get available Services for HTTPRoute backend selection\n * @param ddClient Docker Desktop client\n * @param namespace Namespace to search for services\n * @returns List of available Services with their ports\n */\nexport const getAvailableServices = async (\n  ddClient: v1.DockerDesktopClient,\n  namespace: string\n): Promise<{ items: Array<{ name: string; namespace: string; ports: Array<{ name?: string; port: number; protocol: string }> }>; error?: string }> => {\n  try {\n    const output = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"services\",\n      \"-n\",\n      namespace,\n      \"-o\",\n      \"json\"\n    ]);\n\n    if (output?.stderr && !output.stderr.includes(\"not found\")) {\n      return { items: [], error: output.stderr };\n    }\n\n    try {\n      const result = JSON.parse(output?.stdout || '{\"items\":[]}');\n      const services = result.items || [];\n\n      const availableServices = services.map((svc: any) => ({\n        name: svc.metadata.name,\n        namespace: svc.metadata.namespace,\n        ports: (svc.spec.ports || []).map((port: any) => ({\n          name: port.name,\n          port: port.port,\n          protocol: port.protocol || 'TCP'\n        }))\n      }));\n\n      return { items: availableServices };\n    } catch (e) {\n      return { items: [], error: 'Failed to parse Services JSON' };\n    }\n  } catch (error: any) {\n    console.error(\"Error getting available Services:\", error);\n    return {\n      items: [],\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Check Gateway compatibility for HTTPRoute\n * @param ddClient Docker Desktop client\n * @param gatewayName Gateway name\n * @param gatewayNamespace Gateway namespace\n * @param routeNamespace HTTPRoute namespace\n * @returns Compatibility check result\n */\nexport const checkGatewayCompatibility = async (\n  ddClient: v1.DockerDesktopClient,\n  gatewayName: string,\n  gatewayNamespace: string,\n  routeNamespace: string\n): Promise<{ compatible: boolean; message?: string; listeners?: string[] }> => {\n  try {\n    const gatewayStatus = await getGatewayStatus(ddClient, gatewayNamespace, gatewayName);\n\n    if (gatewayStatus.status === 'unknown' || gatewayStatus.status === 'failed') {\n      return {\n        compatible: false,\n        message: `Gateway is not ready: ${gatewayStatus.message}`\n      };\n    }\n\n    // Get Gateway details to check listener configuration\n    const gatewayOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"gateway\",\n      \"-n\",\n      gatewayNamespace,\n      gatewayName,\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!gatewayOutput?.stdout || gatewayOutput.stdout.trim() === \"\") {\n      return {\n        compatible: false,\n        message: `Gateway '${gatewayName}' not found in namespace '${gatewayNamespace}'`\n      };\n    }\n\n    const gateway: Gateway = JSON.parse(gatewayOutput.stdout);\n    const httpListeners = gateway.spec.listeners.filter(l =>\n      l.protocol === 'HTTP' || l.protocol === 'HTTPS'\n    );\n\n    if (httpListeners.length === 0) {\n      return {\n        compatible: false,\n        message: 'Gateway has no HTTP/HTTPS listeners that can accept HTTPRoutes'\n      };\n    }\n\n    // Check if any listener allows HTTPRoutes from the route's namespace\n    const compatibleListeners = httpListeners.filter(listener => {\n      const allowedRoutes = listener.allowedRoutes;\n\n      if (!allowedRoutes || !allowedRoutes.namespaces) {\n        return true; // Default allows same namespace\n      }\n\n      const namespacePolicy = allowedRoutes.namespaces.from;\n\n      if (namespacePolicy === 'All') {\n        return true;\n      } else if (namespacePolicy === 'Same') {\n        return gatewayNamespace === routeNamespace;\n      } else if (namespacePolicy === 'Selector') {\n        // For simplicity, assume selector allows the namespace\n        // In a real implementation, we'd check the selector against namespace labels\n        return true;\n      }\n\n      return false;\n    });\n\n    if (compatibleListeners.length === 0) {\n      return {\n        compatible: false,\n        message: `Gateway listeners do not allow HTTPRoutes from namespace '${routeNamespace}'`\n      };\n    }\n\n    return {\n      compatible: true,\n      message: `Gateway is compatible with ${compatibleListeners.length} listener(s)`,\n      listeners: compatibleListeners.map(l => `${l.name} (${l.protocol}:${l.port})`)\n    };\n  } catch (error: any) {\n    console.error(\"Error checking Gateway compatibility:\", error);\n    return {\n      compatible: false,\n      message: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n","/Users/saptak/code/envddext/ui/src/AppWithGitHubTemplates.tsx",["137","138","139","140","141"],[],"import React from \"react\";\nimport {\n  Typography,\n  Box,\n  Paper,\n  Divider,\n  CircularProgress,\n  Button,\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogContentText,\n  DialogActions,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemIcon,\n  Card,\n  CardContent,\n  CardActions,\n  Grid,\n  Snackbar,\n  Alert,\n  Tab,\n  Tabs\n} from \"@mui/material\";\nimport { createDockerDesktopClient } from \"@docker/extension-api-client\";\nimport { listEnvoyGateways, listEnvoyHTTPRoutes, checkEnvoyGatewayCRDs, installEnvoyGateway } from \"./helper/kubernetes\";\nimport {\n  fetchTemplatesMetadata,\n  loadTemplate,\n  applyTemplateFromUrl,\n  Template,\n  TemplateMetadata,\n  checkDeploymentStatus\n} from \"./services/githubTemplateService\";\nimport { DeploymentStatusMonitor } from \"./components/DeploymentStatusMonitor\";\nimport { GatewayManagement } from \"./components/GatewayManagement\";\nimport { HTTPClient } from \"./components/HTTPClient\";\nimport { ProxyManager } from \"./components/ProxyManager\";\n\nconst ddClient = createDockerDesktopClient();\n\nexport function App() {\n  // State for Envoy Gateway resources\n  const [gateways, setGateways] = React.useState<any[]>([]);\n  const [routes, setRoutes] = React.useState<any[]>([]);\n  const [loading, setLoading] = React.useState<boolean>(true);\n  const [error, setError] = React.useState<string | null>(null);\n  const [isEnvoyGatewayInstalled, setIsEnvoyGatewayInstalled] = React.useState<boolean>(false);\n  const [isInstalling, setIsInstalling] = React.useState<boolean>(false);\n  const [installationError, setInstallationError] = React.useState<string | null>(null);\n  const [quickStartDialogOpen, setQuickStartDialogOpen] = React.useState<boolean>(false);\n\n  // Template related state\n  const [templates, setTemplates] = React.useState<TemplateMetadata[]>([]);\n  const [selectedTemplate, setSelectedTemplate] = React.useState<Template | null>(null);\n  const [templateYaml, setTemplateYaml] = React.useState<string>('');\n  const [isApplyingTemplate, setIsApplyingTemplate] = React.useState(false);\n  const [templateError, setTemplateError] = React.useState<string | null>(null);\n  const [templateSuccess, setTemplateSuccess] = React.useState<boolean>(false);\n  const [isLoadingTemplates, setIsLoadingTemplates] = React.useState<boolean>(false);\n\n  // Add new state variables\n  const [deploymentStatus, setDeploymentStatus] = React.useState<{\n    status: 'pending' | 'ready' | 'failed';\n    message?: string;\n  } | null>(null);\n  const [statusCheckInterval, setStatusCheckInterval] = React.useState<NodeJS.Timeout | null>(null);\n\n  // Add tab state and deployed services tracking\n  const [currentTab, setCurrentTab] = React.useState<number>(0);\n  const [deployedServices, setDeployedServices] = React.useState<{\n    namespace: string;\n    deploymentName: string;\n    serviceName: string;\n  }[]>([\n    // Default echo service from basic-http template\n    {\n      namespace: 'demo',\n      deploymentName: 'echo-service',\n      serviceName: 'echo-service'\n    }\n  ]);\n\n  const fetchData = React.useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    const installed = await checkEnvoyGatewayCRDs(ddClient);\n    setIsEnvoyGatewayInstalled(installed);\n\n    if (installed) {\n      try {\n        const gwResult = await listEnvoyGateways(ddClient);\n        const rtResult = await listEnvoyHTTPRoutes(ddClient);\n        if (gwResult.error) {\n          console.error('Gateway error:', gwResult.error);\n          setError(gwResult.error);\n        }\n        if (rtResult.error) {\n          console.error('Route error:', rtResult.error);\n          setError(rtResult.error);\n        }\n        setGateways(gwResult.items || []);\n        setRoutes(rtResult.items || []);\n      } catch (e: any) {\n        console.error('Caught error:', e);\n        setError(typeof e === 'string' ? e : JSON.stringify(e, null, 2));\n      }\n    }\n    setLoading(false);\n  }, [ddClient]);\n\n  React.useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  const handleInstallClick = async () => {\n    setIsInstalling(true);\n    setInstallationError(null);\n    setError(null); // Clear general error when starting installation\n    try {\n      // TODO: Allow user to specify version?\n      const result = await installEnvoyGateway(ddClient, \"latest\"); // Using latest version\n      if (result.error) {\n        console.error('Installation error:', result.error);\n        setInstallationError(result.error);\n      } else {\n        // Installation successful, re-check CRDs and fetch data\n        await fetchData();\n      }\n    } catch (e: any) {\n      console.error('Caught installation error:', e);\n      setInstallationError(typeof e === 'string' ? e : JSON.stringify(e, null, 2));\n    }\n    setIsInstalling(false);\n  };\n\n  const handleQuickStartOpen = async () => {\n    setIsLoadingTemplates(true);\n    setTemplateError(null);\n    setTemplateSuccess(false);\n    setQuickStartDialogOpen(true);\n\n    try {\n      // Fetch templates metadata from GitHub\n      const templatesMetadata = await fetchTemplatesMetadata();\n      setTemplates(templatesMetadata);\n    } catch (error: any) {\n      console.error('Error fetching templates:', error);\n      setTemplateError(typeof error === 'string' ? error : JSON.stringify(error, null, 2));\n    } finally {\n      setIsLoadingTemplates(false);\n    }\n\n    setSelectedTemplate(null);\n    setTemplateYaml('');\n  };\n\n  const handleQuickStartClose = () => {\n    setQuickStartDialogOpen(false);\n  };\n\n  // Handle tab change\n  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {\n    setCurrentTab(newValue);\n  };\n\n  const handleTemplateSelect = async (templateId: string) => {\n    setTemplateError(null);\n    setTemplateSuccess(false);\n    setIsLoadingTemplates(true);\n\n    try {\n      const template = await loadTemplate(templateId);\n      setSelectedTemplate(template);\n\n      if (template) {\n        // Set the YAML content\n        setTemplateYaml(template.yamlContent);\n      } else {\n        setTemplateError(`Failed to load template: ${templateId}`);\n      }\n    } catch (e: any) {\n      console.error('Error loading template:', e);\n      setTemplateError(typeof e === 'string' ? e : JSON.stringify(e, null, 2));\n    } finally {\n      setIsLoadingTemplates(false);\n    }\n  };\n\n  // Add status checking function\n  const checkTemplateDeploymentStatus = async () => {\n    if (!selectedTemplate) return;\n\n    try {\n      const status = await checkDeploymentStatus(ddClient, selectedTemplate);\n      setDeploymentStatus(status);\n\n      if (status.status === 'ready' || status.status === 'failed') {\n        if (statusCheckInterval) {\n          clearInterval(statusCheckInterval);\n          setStatusCheckInterval(null);\n        }\n      }\n    } catch (error) {\n      console.error('Error checking deployment status:', error);\n      setDeploymentStatus({\n        status: 'failed',\n        message: 'Failed to check deployment status'\n      });\n    }\n  };\n\n  // Update handleApplyTemplate\n  const handleApplyTemplate = async () => {\n    if (!selectedTemplate) return;\n\n    setIsApplyingTemplate(true);\n    setTemplateError(null);\n    setTemplateSuccess(false);\n    setDeploymentStatus(null);\n\n    try {\n      // Apply the template using the GitHub template service\n      const result = await applyTemplateFromUrl(ddClient, selectedTemplate.metadata.yamlUrl);\n\n      if (result.success) {\n        setTemplateSuccess(true);\n        // Start checking deployment status\n        const interval = setInterval(checkTemplateDeploymentStatus, 2000);\n        setStatusCheckInterval(interval);\n        // Initial check\n        await checkTemplateDeploymentStatus();\n\n        // Refresh the UI with the latest gateways and routes\n        await fetchData();\n\n        // Track deployed services based on template ID\n        if (selectedTemplate.metadata.id === 'basic-http-echo') {\n          // Check if service is already tracked\n          const exists = deployedServices.some(\n            service => service.namespace === 'demo' && service.deploymentName === 'echo-service'\n          );\n\n          if (!exists) {\n            setDeployedServices(prev => [\n              ...prev,\n              {\n                namespace: 'demo',\n                deploymentName: 'echo-service',\n                serviceName: 'echo-service'\n              }\n            ]);\n          }\n\n          // Switch to the Deployment Status tab\n          setCurrentTab(2);\n        }\n      } else {\n        setTemplateError(result.error || 'Failed to apply template');\n      }\n    } catch (error: any) {\n      setTemplateError(typeof error === 'string' ? error : JSON.stringify(error, null, 2));\n    } finally {\n      setIsApplyingTemplate(false);\n    }\n  };\n\n  // Add function to apply template directly from URL\n  const handleApplyTemplateFromUrl = async (url: string) => {\n    setIsApplyingTemplate(true);\n    setTemplateError(null);\n    setTemplateSuccess(false);\n    setDeploymentStatus(null);\n\n    try {\n      // Apply the template directly from the URL\n      const result = await applyTemplateFromUrl(ddClient, url);\n\n      if (result.success) {\n        setTemplateSuccess(true);\n        // Start checking deployment status\n        const interval = setInterval(checkTemplateDeploymentStatus, 2000);\n        setStatusCheckInterval(interval);\n        // Initial check\n        await checkTemplateDeploymentStatus();\n\n        // Refresh the UI with the latest gateways and routes\n        await fetchData();\n\n        // Track deployed services based on URL\n        // Check if it's a basic-http template\n        if (url.includes('basic-http') || url.includes('echo-service')) {\n          // Check if service is already tracked\n          const exists = deployedServices.some(\n            service => service.namespace === 'demo' && service.deploymentName === 'echo-service'\n          );\n\n          if (!exists) {\n            setDeployedServices(prev => [\n              ...prev,\n              {\n                namespace: 'demo',\n                deploymentName: 'echo-service',\n                serviceName: 'echo-service'\n              }\n            ]);\n          }\n\n          // Switch to the Deployment Status tab\n          setCurrentTab(2);\n        }\n      } else {\n        setTemplateError(result.error || 'Failed to apply template from URL');\n      }\n    } catch (error: any) {\n      setTemplateError(typeof error === 'string' ? error : JSON.stringify(error, null, 2));\n    } finally {\n      setIsApplyingTemplate(false);\n    }\n  };\n\n  return (\n    <Box sx={{ p: 4 }}>\n      <Typography variant=\"h4\" gutterBottom>\n        Envoy Gateway\n      </Typography>\n      <Typography variant=\"body1\" color=\"text.secondary\" sx={{ mb: 3 }}>\n        Manage and observe Envoy Gateway resources in your local Kubernetes cluster using Docker Desktop.\n      </Typography>\n\n      {/* Backend Status and Summary */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Typography variant=\"subtitle1\">Backend Status: <b>{error || installationError ? \"error\" : \"ok\"}</b></Typography>\n        <Typography variant=\"subtitle1\">Kubernetes: <b>{loading || isInstalling ? \"Loading...\" : \"Ready\"}</b></Typography>\n        <Typography variant=\"subtitle1\">Gateways: <b>{gateways.length}</b></Typography>\n        <Typography variant=\"subtitle1\">Routes: <b>{routes.length}</b></Typography>\n      </Paper>\n\n      {loading || isInstalling ? (\n        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 5 }}>\n          <CircularProgress />\n          {isInstalling && <Typography variant=\"body1\" sx={{ ml: 2 }}>Installing Envoy Gateway...</Typography>}\n        </Box>\n      ) : error || installationError ? (\n        <Paper sx={{ p: 2, mb: 3 }}>\n          <Typography color=\"error\" sx={{ whiteSpace: 'pre-wrap' }}>\n            Error: {typeof (error || installationError) === 'string' ? (error || installationError) : JSON.stringify((error || installationError), null, 2)}\n          </Typography>\n        </Paper>\n      ) : !isEnvoyGatewayInstalled ? (\n        <Paper sx={{ p: 2, mb: 3 }}>\n          <Typography variant=\"h6\" gutterBottom>Envoy Gateway Not Installed</Typography>\n          <Typography variant=\"body1\" color=\"text.secondary\" sx={{ mb: 2 }}>\n            Envoy Gateway Custom Resource Definitions (CRDs) were not found in your Kubernetes cluster.\n            Please install Envoy Gateway to use this extension.\n          </Typography>\n          <Button\n            variant=\"contained\"\n            color=\"primary\"\n            onClick={handleInstallClick}\n            disabled={isInstalling}\n          >\n            {isInstalling ? \"Installing...\" : \"Install Envoy Gateway\"}\n          </Button>\n           {installationError && (\n             <Typography color=\"error\" sx={{ whiteSpace: 'pre-wrap', mt: 2 }}>\n               Installation Error: {typeof installationError === 'string' ? installationError : JSON.stringify(installationError, null, 2)}\n             </Typography>\n           )}\n        </Paper>\n      ) : (\n        <>\n          {/* Main Content */}\n          <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>\n            <Box sx={{ display: 'flex', gap: 2 }}>\n              <Button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={handleQuickStartOpen}\n              >\n                Quick Start\n              </Button>\n              <Button\n                variant=\"outlined\"\n                color=\"secondary\"\n                onClick={fetchData}\n                disabled={loading}\n              >\n                {loading ? \"Refreshing...\" : \"Refresh Resources\"}\n              </Button>\n            </Box>\n          </Box>\n\n          {/* Tabs for different views */}\n          <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>\n            <Tabs value={currentTab} onChange={handleTabChange} aria-label=\"envoy gateway tabs\">\n              <Tab label=\"Resources\" id=\"tab-0\" aria-controls=\"tabpanel-0\" />\n              <Tab label=\"Gateway Management\" id=\"tab-1\" aria-controls=\"tabpanel-1\" />\n              <Tab label=\"Deployment Status\" id=\"tab-2\" aria-controls=\"tabpanel-2\" />\n              <Tab label=\"HTTP Testing\" id=\"tab-3\" aria-controls=\"tabpanel-3\" />\n              <Tab label=\"Proxy Manager\" id=\"tab-4\" aria-controls=\"tabpanel-4\" />\n            </Tabs>\n          </Box>\n\n          {/* Resources Tab */}\n          <Box\n            role=\"tabpanel\"\n            hidden={currentTab !== 0}\n            id=\"tabpanel-0\"\n            aria-labelledby=\"tab-0\"\n          >\n            {currentTab === 0 && (\n              <>\n                {/* Gateways Section */}\n                <Paper sx={{ p: 2, mb: 3 }}>\n                  <Typography variant=\"h6\">Gateways</Typography>\n                  <Divider sx={{ my: 1 }} />\n                  {gateways.length === 0 ? (\n                    <Typography variant=\"body2\" color=\"text.secondary\">\n                      No gateways found\n                    </Typography>\n                  ) : (\n                    gateways.map((gw: any) => (\n                      <Typography key={gw.metadata.uid} variant=\"body2\">\n                        {gw.metadata.name} (ns: {gw.metadata.namespace})\n                      </Typography>\n                    ))\n                  )}\n                </Paper>\n\n                {/* Routes Section */}\n                <Paper sx={{ p: 2, mb: 3 }}>\n                  <Typography variant=\"h6\">Routes</Typography>\n                  <Divider sx={{ my: 1 }} />\n                  {routes.length === 0 ? (\n                    <Typography variant=\"body2\" color=\"text.secondary\">\n                      No routes found\n                    </Typography>\n                  ) : (\n                    routes.map((rt: any) => (\n                      <Typography key={rt.metadata.uid} variant=\"body2\">\n                        {rt.metadata.name} (ns: {rt.metadata.namespace})\n                      </Typography>\n                    ))\n                  )}\n                </Paper>\n              </>\n            )}\n          </Box>\n\n          {/* Gateway Management Tab */}\n          <Box\n            role=\"tabpanel\"\n            hidden={currentTab !== 1}\n            id=\"tabpanel-1\"\n            aria-labelledby=\"tab-1\"\n          >\n            {currentTab === 1 && (\n              <GatewayManagement\n                onGatewayCreated={(gateway) => {\n                  // Refresh the gateways list when a new gateway is created\n                  fetchData();\n                }}\n              />\n            )}\n          </Box>\n\n          {/* Deployment Status Tab */}\n          <Box\n            role=\"tabpanel\"\n            hidden={currentTab !== 2}\n            id=\"tabpanel-2\"\n            aria-labelledby=\"tab-2\"\n          >\n            {currentTab === 2 && (\n              <>\n                <Typography variant=\"h6\" gutterBottom>\n                  Deployment Status\n                </Typography>\n                <Typography variant=\"body2\" color=\"text.secondary\" paragraph>\n                  Monitor the status of your deployed services. This view provides detailed information about pods, containers, and troubleshooting guidance.\n                </Typography>\n\n                {deployedServices.map((service, index) => (\n                  <DeploymentStatusMonitor\n                    key={index}\n                    ddClient={ddClient}\n                    namespace={service.namespace}\n                    deploymentName={service.deploymentName}\n                    serviceName={service.serviceName}\n                    autoRefresh={true}\n                    refreshInterval={5000}\n                  />\n                ))}\n\n                {deployedServices.length === 0 && (\n                  <Paper sx={{ p: 2, textAlign: 'center' }}>\n                    <Typography variant=\"body1\" color=\"text.secondary\">\n                      No deployments found. Apply a template to create deployments.\n                    </Typography>\n                  </Paper>\n                )}\n              </>\n            )}\n          </Box>\n\n          {/* HTTP Testing Tab */}\n          <Box\n            role=\"tabpanel\"\n            hidden={currentTab !== 3}\n            id=\"tabpanel-3\"\n            aria-labelledby=\"tab-3\"\n          >\n            {currentTab === 3 && (\n              <>\n                <Typography variant=\"h6\" gutterBottom>\n                  HTTP Testing\n                </Typography>\n                <Typography variant=\"body2\" color=\"text.secondary\" paragraph>\n                  Test your deployed Envoy Gateway services with HTTP requests. Use this tool to verify your routes and gateways are working correctly.\n                </Typography>\n                <HTTPClient />\n              </>\n            )}\n          </Box>\n\n          {/* Proxy Manager Tab */}\n          <Box\n            role=\"tabpanel\"\n            hidden={currentTab !== 4}\n            id=\"tabpanel-4\"\n            aria-labelledby=\"tab-4\"\n          >\n            {currentTab === 4 && (\n              <>\n                <Typography variant=\"h6\" gutterBottom>\n                  Proxy Manager\n                </Typography>\n                <Typography variant=\"body2\" color=\"text.secondary\" paragraph>\n                  Manage kubectl proxy connections to access Kubernetes services directly. Enable proxy to test internal services and APIs.\n                </Typography>\n                <ProxyManager />\n              </>\n            )}\n          </Box>\n        </>\n      )}\n\n      {/* Quick Start Dialog */}\n      <Dialog\n        open={quickStartDialogOpen}\n        onClose={handleQuickStartClose}\n        maxWidth=\"md\"\n        fullWidth\n      >\n        <DialogTitle>\n           Envoy Gateway Quick Start\n        </DialogTitle>\n        <DialogContent>\n          <DialogContentText sx={{ mb: 2 }}>\n            Welcome to the Envoy Gateway Quick Start! This wizard will help you get started with common Envoy Gateway use cases. Choose one of the examples below to deploy a complete working configuration to your Kubernetes cluster.\n          </DialogContentText>\n\n          {isLoadingTemplates && (\n            <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>\n              <CircularProgress />\n              <Typography variant=\"body1\" sx={{ ml: 2 }}>Loading templates...</Typography>\n            </Box>\n          )}\n\n          {templateError && (\n            <Alert severity=\"error\" sx={{ mb: 2 }}>\n              <Typography variant=\"subtitle2\" fontWeight=\"bold\">Error:</Typography>\n              <Typography variant=\"body2\" sx={{ whiteSpace: 'pre-wrap' }}>\n                {templateError}\n              </Typography>\n              {templateError.includes(\"Gateway API CRDs are not installed\") && (\n                <Box sx={{ mt: 1 }}>\n                  <Typography variant=\"subtitle2\">Troubleshooting:</Typography>\n                  <Typography variant=\"body2\">\n                    1. Make sure Envoy Gateway is installed by clicking the \"Install Envoy Gateway\" button on the main page.\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    2. If the issue persists, try restarting Docker Desktop and Kubernetes.\n                  </Typography>\n                </Box>\n              )}\n              {templateError.includes(\"Failed to create GatewayClass\") && (\n                <Box sx={{ mt: 1 }}>\n                  <Typography variant=\"subtitle2\">Troubleshooting:</Typography>\n                  <Typography variant=\"body2\">\n                    1. Check if Kubernetes is running properly.\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    2. Verify that Envoy Gateway is installed correctly.\n                  </Typography>\n                </Box>\n              )}\n            </Alert>\n          )}\n\n          {templateSuccess && (\n            <Alert severity=\"success\" sx={{ mb: 2 }}>\n              Template applied successfully!\n            </Alert>\n          )}\n\n          {!selectedTemplate ? (\n            <>\n              <Typography variant=\"subtitle1\" sx={{ mt: 3, mb: 1 }}>\n                Available Examples:\n              </Typography>\n              <Grid container spacing={2}>\n                {templates.map((template) => (\n                  <Grid item xs={12} md={6} key={template.id}>\n                    <Card variant=\"outlined\">\n                      <CardContent>\n                        <Typography variant=\"h6\" gutterBottom>\n                          {template.name}\n                        </Typography>\n                        <Typography variant=\"body2\" color=\"text.secondary\">\n                          {template.description}\n                        </Typography>\n                        <Typography variant=\"caption\" color=\"text.secondary\" sx={{ display: 'block', mt: 1 }}>\n                          Difficulty: {template.difficulty}\n                        </Typography>\n                      </CardContent>\n                      <CardActions>\n                        <Button\n                          size=\"small\"\n                          color=\"primary\"\n                          onClick={() => handleTemplateSelect(template.id)}\n                        >\n                          Select\n                        </Button>\n                        <Button\n                          size=\"small\"\n                          color=\"secondary\"\n                          onClick={() => handleApplyTemplateFromUrl(template.yamlUrl)}\n                        >\n                          Apply Directly\n                        </Button>\n                      </CardActions>\n                    </Card>\n                  </Grid>\n                ))}\n              </Grid>\n            </>\n          ) : (\n            <>\n              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>\n                <Typography variant=\"h6\">\n                  {selectedTemplate.metadata.name}\n                </Typography>\n                <Button\n                  variant=\"outlined\"\n                  size=\"small\"\n                  onClick={() => {\n                    setSelectedTemplate(null);\n                    if (statusCheckInterval) {\n                      clearInterval(statusCheckInterval);\n                      setStatusCheckInterval(null);\n                    }\n                    setDeploymentStatus(null);\n                  }}\n                >\n                  Back to Templates\n                </Button>\n              </Box>\n\n              <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mb: 2 }}>\n                {selectedTemplate.metadata.description}\n              </Typography>\n\n              {deploymentStatus && (\n                <Alert\n                  severity={\n                    deploymentStatus.status === 'ready' ? 'success' :\n                    deploymentStatus.status === 'failed' ? 'error' : 'info'\n                  }\n                  sx={{ mb: 2 }}\n                >\n                  <Typography variant=\"subtitle2\" fontWeight=\"bold\">\n                    {deploymentStatus.status === 'ready' ? 'Deployment Status: Ready' :\n                     deploymentStatus.status === 'failed' ? 'Deployment Status: Failed' :\n                     'Deployment Status: In Progress'}\n                  </Typography>\n                  <Typography variant=\"body2\" sx={{ whiteSpace: 'pre-wrap' }}>\n                    {deploymentStatus.message}\n                  </Typography>\n                </Alert>\n              )}\n\n              <Typography variant=\"subtitle1\" sx={{ mt: 3, mb: 1 }}>\n                Template YAML:\n              </Typography>\n\n              <Paper\n                elevation={0}\n                variant=\"outlined\"\n                sx={{\n                  mb: 2,\n                  maxHeight: '300px',\n                  overflow: 'auto',\n                  backgroundColor: 'rgba(0, 0, 0, 0.04)'\n                }}\n              >\n                <Box\n                  component=\"pre\"\n                  sx={{\n                    fontFamily: 'monospace',\n                    fontSize: '0.875rem',\n                    p: 2,\n                    m: 0,\n                    overflowX: 'auto',\n                    whiteSpace: 'pre-wrap',\n                    wordBreak: 'break-word'\n                  }}\n                >\n                  {templateYaml}\n                </Box>\n              </Paper>\n\n              <Box sx={{ display: 'flex', gap: 2 }}>\n                <Button\n                  variant=\"contained\"\n                  color=\"primary\"\n                  onClick={handleApplyTemplate}\n                  disabled={isApplyingTemplate}\n                  sx={{ mt: 2 }}\n                >\n                  {isApplyingTemplate ? \"Applying...\" : \"Apply Template\"}\n                </Button>\n\n                <Button\n                  variant=\"outlined\"\n                  color=\"secondary\"\n                  onClick={() => handleApplyTemplateFromUrl(selectedTemplate.metadata.yamlUrl)}\n                  disabled={isApplyingTemplate}\n                  sx={{ mt: 2 }}\n                >\n                  Apply Directly from GitHub\n                </Button>\n              </Box>\n            </>\n          )}\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleQuickStartClose} color=\"primary\">\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n\n      {/* Success Snackbar */}\n      <Snackbar\n        open={templateSuccess}\n        autoHideDuration={6000}\n        onClose={() => setTemplateSuccess(false)}\n      >\n        <Alert onClose={() => setTemplateSuccess(false)} severity=\"success\">\n          Template applied successfully!\n        </Alert>\n      </Snackbar>\n    </Box>\n  );\n}\n","/Users/saptak/code/envddext/ui/src/services/githubTemplateService.ts",["142"],[],"import { v1 } from \"@docker/extension-api-client-types\";\n\n// Template metadata interface\nexport interface TemplateMetadata {\n  id: string;\n  name: string;\n  description: string;\n  category: string;\n  difficulty: 'beginner' | 'intermediate' | 'advanced';\n  yamlUrl: string; // URL to the raw YAML file\n}\n\n// Template interface\nexport interface Template {\n  metadata: TemplateMetadata;\n  yamlContent: string; // The raw YAML content\n}\n\n// GitHub repository information\nconst GITHUB_REPO_OWNER = \"saptak\"; // GitHub username\nconst GITHUB_REPO_NAME = \"envoygatewaytemplates\";\nconst GITHUB_BRANCH = \"main\";\n\n// Base URL for raw GitHub content\nconst GITHUB_RAW_BASE_URL = `https://raw.githubusercontent.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/${GITHUB_BRANCH}`;\n\n// URL to the template index file\nconst TEMPLATE_INDEX_URL = `${GITHUB_RAW_BASE_URL}/templates/index.json`;\n\n// Available templates (fallback if GitHub fetch fails)\nconst fallbackTemplates: Record<string, TemplateMetadata> = {\n  'basic-http-echo': {\n    id: 'basic-http-echo',\n    name: 'Basic HTTP Echo Service',\n    description: 'Deploy a simple echo service with HTTP routing through Envoy Gateway',\n    category: 'basic-http',\n    difficulty: 'beginner',\n    yamlUrl: `${GITHUB_RAW_BASE_URL}/templates/basic-http/echo-service.yaml`\n  },\n  'tls-termination': {\n    id: 'tls-termination',\n    name: 'TLS Termination',\n    description: 'Secure your services with HTTPS using TLS termination at the Gateway',\n    category: 'tls',\n    difficulty: 'intermediate',\n    yamlUrl: `${GITHUB_RAW_BASE_URL}/templates/tls-termination/tls-termination.yaml`\n  },\n  'traffic-splitting': {\n    id: 'traffic-splitting',\n    name: 'Traffic Splitting',\n    description: 'Route traffic to multiple versions of a service with weighted routing',\n    category: 'traffic-splitting',\n    difficulty: 'intermediate',\n    yamlUrl: `${GITHUB_RAW_BASE_URL}/templates/traffic-splitting/traffic-splitting.yaml`\n  }\n};\n\n/**\n * Fetch templates metadata from GitHub\n */\nexport const fetchTemplatesMetadata = async (): Promise<TemplateMetadata[]> => {\n  try {\n    // Fetch the template index from GitHub\n    const response = await fetch(TEMPLATE_INDEX_URL);\n    if (!response.ok) {\n      console.warn(`Failed to fetch templates from GitHub: ${response.statusText}`);\n      return Object.values(fallbackTemplates);\n    }\n\n    const templates = await response.json();\n    return templates;\n  } catch (error) {\n    console.error('Error fetching templates from GitHub:', error);\n    // Return fallback templates if GitHub fetch fails\n    return Object.values(fallbackTemplates);\n  }\n};\n\n/**\n * Load a template by ID\n * @param id Template ID\n */\nexport const loadTemplate = async (id: string): Promise<Template | null> => {\n  try {\n    // First, get the template metadata\n    const templates = await fetchTemplatesMetadata();\n    const metadata = templates.find(t => t.id === id);\n\n    if (!metadata) {\n      console.error(`Template with ID ${id} not found`);\n      return null;\n    }\n\n    // Fetch the YAML content from GitHub\n    const response = await fetch(metadata.yamlUrl);\n    if (!response.ok) {\n      console.error(`Failed to fetch template YAML from GitHub: ${response.statusText}`);\n      return null;\n    }\n\n    const yamlContent = await response.text();\n\n    return {\n      metadata,\n      yamlContent\n    };\n  } catch (error) {\n    console.error(`Error loading template ${id}:`, error);\n    return null;\n  }\n};\n\n\n/**\n * Apply a template directly from a GitHub URL\n * @param ddClient Docker Desktop client\n * @param url URL to the raw YAML file\n */\nexport const applyTemplateFromUrl = async (\n  ddClient: v1.DockerDesktopClient,\n  url: string\n): Promise<{ success: boolean; error?: string }> => {\n  try {\n    // First, ensure the GatewayClass exists\n    const gcResult = await ensureGatewayClass(ddClient);\n    if (!gcResult.success) {\n      return gcResult;\n    }\n\n    // Use the VM backend to apply the template\n    console.log(`Applying template via backend from URL: ${url}`);\n\n    const response = await ddClient.extension.vm?.service?.post('/apply-template', { url }) as any;\n\n    if (response?.success) {\n      return { success: true };\n    } else {\n      return { success: false, error: response?.error || 'Unknown error applying template' };\n    }\n  } catch (error: any) {\n    console.error(\"Error applying template from URL:\", error);\n    return {\n      success: false,\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Check if GatewayClass exists and create it if it doesn't\n * @param ddClient Docker Desktop client\n */\nexport const ensureGatewayClass = async (\n  ddClient: v1.DockerDesktopClient\n): Promise<{ success: boolean; error?: string }> => {\n  try {\n    console.log(\"Checking if GatewayClass 'envoy-gateway' exists...\");\n\n    // First, check if the Gateway API CRDs are installed\n    const crdOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"crd\",\n      \"gatewayclasses.gateway.networking.k8s.io\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!crdOutput?.stdout || crdOutput.stdout.trim() === \"\") {\n      console.error(\"Gateway API CRDs not found\");\n      return {\n        success: false,\n        error: \"Gateway API CRDs are not installed. Please make sure Envoy Gateway is properly installed.\"\n      };\n    }\n\n    // Check if GatewayClass exists\n    const gcOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"gatewayclass\",\n      \"envoy-gateway\",\n      \"--ignore-not-found\"\n    ]);\n\n    // If GatewayClass doesn't exist, create it\n    if (!gcOutput?.stdout || gcOutput.stdout.trim() === \"\") {\n      console.log(\"GatewayClass 'envoy-gateway' not found, creating it...\");\n\n      const gatewayClassYaml = `apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: envoy-gateway\nspec:\n  controllerName: gateway.envoyproxy.io/gatewayclass-controller`;\n\n      // Apply the GatewayClass using kubectl apply\n      console.log(`Applying GatewayClass using kubectl apply`);\n\n      // Apply the GatewayClass directly from a URL\n      // Use a raw GitHub URL to the GatewayClass YAML from your repository\n      const gatewayClassUrl = \"https://raw.githubusercontent.com/saptak/envoygatewaytemplates/main/gatewayclass.yaml\";\n      console.log(`Applying GatewayClass from URL: ${gatewayClassUrl}`);\n\n      // Apply the resource directly from the URL\n      const applyResult = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n        \"apply\", \"-f\", gatewayClassUrl\n      ]);\n\n      console.log(\"GatewayClass creation result:\", applyResult);\n\n      // Check for errors\n      if (applyResult?.stderr &&\n          !applyResult.stderr.includes('configured') &&\n          !applyResult.stderr.includes(' unchanged') &&\n          !applyResult.stderr.includes(' created')) {\n        return {\n          success: false,\n          error: `Failed to create GatewayClass: ${applyResult.stderr || \"Unknown error\"}`\n        };\n      }\n\n      // Verify the GatewayClass was created\n      const verifyOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n        \"get\",\n        \"gatewayclass\",\n        \"envoy-gateway\",\n        \"--ignore-not-found\"\n      ]);\n\n      if (!verifyOutput?.stdout || verifyOutput.stdout.trim() === \"\") {\n        return {\n          success: false,\n          error: \"Failed to verify GatewayClass creation\"\n        };\n      }\n    }\n\n    return { success: true };\n  } catch (error: any) {\n    console.error(\"Error ensuring GatewayClass:\", error);\n    return {\n      success: false,\n      error: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n\n/**\n * Check deployment status for a template\n * @param ddClient Docker Desktop client\n * @param template Template to check status for\n */\nexport const checkDeploymentStatus = async (\n  ddClient: v1.DockerDesktopClient,\n  _template: Template // Using underscore to indicate unused parameter\n): Promise<{ status: 'pending' | 'ready' | 'failed'; message?: string }> => {\n  try {\n    // Check GatewayClass first\n    const gcOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"gatewayclass\",\n      \"envoy-gateway\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!gcOutput?.stdout || gcOutput.stdout.trim() === \"\") {\n      console.log(\"GatewayClass 'envoy-gateway' not found\");\n      return {\n        status: 'failed',\n        message: 'GatewayClass \"envoy-gateway\" not found. This is required for the Gateway to function.'\n      };\n    }\n\n    // Check namespace\n    const nsOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"namespace\",\n      \"demo\",\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!nsOutput?.stdout || nsOutput.stdout.trim() === \"\") {\n      console.log(\"Namespace 'demo' not found\");\n      return { status: 'pending', message: 'Namespace not created yet' };\n    }\n\n    // Check deployment\n    const deployOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"deployment\",\n      \"-n\",\n      \"demo\",\n      \"echo-service\",\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!deployOutput?.stdout || deployOutput.stdout.trim() === \"\") {\n      console.log(\"Deployment 'echo-service' not found\");\n      return { status: 'pending', message: 'Deployment not created yet' };\n    }\n\n    try {\n      const deployment = JSON.parse(deployOutput.stdout);\n      const availableReplicas = deployment.status?.availableReplicas || 0;\n      const desiredReplicas = deployment.spec?.replicas || 0;\n      console.log(`Deployment replicas: ${availableReplicas}/${desiredReplicas}`);\n\n      if (availableReplicas < desiredReplicas) {\n        return {\n          status: 'pending',\n          message: `Deployment in progress: ${availableReplicas}/${desiredReplicas} replicas ready`\n        };\n      }\n    } catch (e) {\n      console.error(\"Error parsing deployment JSON:\", e);\n      return { status: 'pending', message: 'Error checking deployment status' };\n    }\n\n    // Check service\n    const svcOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"service\",\n      \"-n\",\n      \"demo\",\n      \"echo-service\",\n      \"--no-headers\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!svcOutput?.stdout || svcOutput.stdout.trim() === \"\") {\n      console.log(\"Service 'echo-service' not found\");\n      return { status: 'pending', message: 'Service not created yet' };\n    }\n\n    // Check gateway\n    const gwOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"gateway\",\n      \"-n\",\n      \"demo\",\n      \"demo-gateway\",\n      \"-o\",\n      \"json\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!gwOutput?.stdout || gwOutput.stdout.trim() === \"\") {\n      console.log(\"Gateway 'demo-gateway' not found\");\n      return { status: 'pending', message: 'Gateway not created yet' };\n    }\n\n    // Check Gateway status\n    try {\n      const gateway = JSON.parse(gwOutput.stdout);\n      const conditions = gateway.status?.conditions || [];\n\n      // Check if Gateway is programmed\n      const programmedCondition = conditions.find((c: any) => c.type === 'Programmed');\n      if (programmedCondition && programmedCondition.status !== 'True') {\n        return {\n          status: 'pending',\n          message: `Gateway not ready: ${programmedCondition.message || 'Waiting for controller'}`\n        };\n      }\n    } catch (e) {\n      console.error(\"Error parsing gateway JSON:\", e);\n    }\n\n    // Check HTTPRoute\n    const routeOutput = await ddClient.extension.host?.cli.exec(\"kubectl\", [\n      \"get\",\n      \"httproute\",\n      \"-n\",\n      \"demo\",\n      \"echo-route\",\n      \"--no-headers\",\n      \"--ignore-not-found\"\n    ]);\n\n    if (!routeOutput?.stdout || routeOutput.stdout.trim() === \"\") {\n      console.log(\"HTTPRoute 'echo-route' not found\");\n      return { status: 'pending', message: 'HTTPRoute not created yet' };\n    }\n\n    // All checks passed\n    return { status: 'ready' };\n  } catch (error: any) {\n    console.error(\"Error checking deployment status:\", error);\n    return {\n      status: 'failed',\n      message: typeof error === 'string' ? error : JSON.stringify(error, null, 2)\n    };\n  }\n};\n","/Users/saptak/code/envddext/ui/src/components/GatewayManagement.tsx",["143","144","145"],[],"import React, { useState, useEffect } from 'react';\nimport {\n  Box,\n  Typography,\n  Button,\n  Paper,\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  Alert,\n  CircularProgress,\n  Divider,\n  Chip,\n  Grid\n} from '@mui/material';\nimport AddIcon from '@mui/icons-material/Add';\nimport RefreshIcon from '@mui/icons-material/Refresh';\nimport { createDockerDesktopClient } from \"@docker/extension-api-client\";\nimport { GatewayCreationForm } from './GatewayCreationForm';\nimport { GatewayStatusMonitor } from './GatewayStatusMonitor';\nimport { LoadBalancerManager } from './LoadBalancerManager';\nimport { listEnvoyGateways } from '../helper/kubernetes';\nimport { Gateway } from '../types/gateway';\nimport { LoadBalancerStatus } from '../services/loadBalancerService';\n\nconst ddClient = createDockerDesktopClient();\n\ninterface GatewayManagementProps {\n  onGatewayCreated?: (gateway: Gateway) => void;\n}\n\nexport const GatewayManagement: React.FC<GatewayManagementProps> = ({\n  onGatewayCreated\n}) => {\n  const [gateways, setGateways] = useState<Gateway[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [showCreateForm, setShowCreateForm] = useState(false);\n  const [createSuccess, setCreateSuccess] = useState<string | null>(null);\n  const [loadBalancerStatus, setLoadBalancerStatus] = useState<LoadBalancerStatus | null>(null);\n\n  useEffect(() => {\n    fetchGateways();\n  }, []);\n\n  const fetchGateways = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const result = await listEnvoyGateways(ddClient);\n      \n      if (result.error) {\n        setError(result.error);\n        setGateways([]);\n      } else {\n        setGateways(result.items || []);\n      }\n    } catch (err: any) {\n      setError(typeof err === 'string' ? err : 'Failed to fetch Gateways');\n      setGateways([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleCreateSuccess = (gateway: Gateway) => {\n    setShowCreateForm(false);\n    setCreateSuccess(`Gateway \"${gateway.metadata.name}\" created successfully!`);\n    \n    // Refresh the gateway list\n    fetchGateways();\n    \n    // Notify parent component\n    onGatewayCreated?.(gateway);\n    \n    // Clear success message after 5 seconds\n    setTimeout(() => setCreateSuccess(null), 5000);\n  };\n\n  const handleGatewayDeleted = () => {\n    // Refresh the gateway list when a gateway is deleted\n    fetchGateways();\n  };\n\n  const handleLoadBalancerStatusChange = (status: LoadBalancerStatus) => {\n    setLoadBalancerStatus(status);\n    // Refresh gateway list if LoadBalancer was just configured\n    if (status.isConfigured && (!loadBalancerStatus || !loadBalancerStatus.isConfigured)) {\n      setTimeout(() => {\n        fetchGateways();\n      }, 3000); // Wait a bit for IP assignments to propagate\n    }\n  };\n\n  const getGatewayStatusSummary = (gateway: Gateway) => {\n    const conditions = gateway.status?.conditions || [];\n    const programmedCondition = conditions.find(c => c.type === 'Programmed');\n    \n    if (programmedCondition) {\n      if (programmedCondition.status === 'True') {\n        return { status: 'ready', color: 'success' as const };\n      } else if (programmedCondition.status === 'False') {\n        return { status: 'failed', color: 'error' as const };\n      }\n    }\n    \n    return { status: 'pending', color: 'warning' as const };\n  };\n\n  return (\n    <Box>\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>\n        <Typography variant=\"h5\">\n          Gateway Management\n        </Typography>\n        <Box sx={{ display: 'flex', gap: 1 }}>\n          <Button\n            variant=\"outlined\"\n            startIcon={<RefreshIcon />}\n            onClick={fetchGateways}\n            disabled={loading}\n          >\n            Refresh\n          </Button>\n          <Button\n            variant=\"contained\"\n            startIcon={<AddIcon />}\n            onClick={() => setShowCreateForm(true)}\n          >\n            Create Gateway\n          </Button>\n        </Box>\n      </Box>\n\n      {createSuccess && (\n        <Alert severity=\"success\" sx={{ mb: 3 }} onClose={() => setCreateSuccess(null)}>\n          {createSuccess}\n        </Alert>\n      )}\n\n      {error && (\n        <Alert severity=\"error\" sx={{ mb: 3 }}>\n          <Typography variant=\"subtitle2\">Error loading Gateways</Typography>\n          <Typography variant=\"body2\">{error}</Typography>\n        </Alert>\n      )}\n\n      {/* LoadBalancer Configuration */}\n      <Box sx={{ mb: 3 }}>\n        <LoadBalancerManager \n          onStatusChange={handleLoadBalancerStatusChange}\n          showConfigureButton={true}\n        />\n      </Box>\n\n      {/* Gateway Address Assignment Warning */}\n      {loadBalancerStatus && !loadBalancerStatus.isConfigured && (\n        <Alert severity=\"warning\" sx={{ mb: 3 }}>\n          <Typography variant=\"subtitle2\">Gateways may not receive IP addresses</Typography>\n          <Typography variant=\"body2\">\n            Without a LoadBalancer controller, your Gateways will remain in \"AddressNotAssigned\" state. \n            Configure a LoadBalancer above to resolve this issue.\n          </Typography>\n        </Alert>\n      )}\n\n      {loading ? (\n        <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>\n          <CircularProgress />\n        </Box>\n      ) : (\n        <>\n          {/* Gateway Summary */}\n          <Paper sx={{ p: 2, mb: 3 }}>\n            <Typography variant=\"h6\" gutterBottom>\n              Gateway Summary\n            </Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ textAlign: 'center' }}>\n                  <Typography variant=\"h4\" color=\"primary\">\n                    {gateways.length}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Total Gateways\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ textAlign: 'center' }}>\n                  <Typography variant=\"h4\" color=\"success.main\">\n                    {gateways.filter(gw => getGatewayStatusSummary(gw).status === 'ready').length}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Ready\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ textAlign: 'center' }}>\n                  <Typography variant=\"h4\" color=\"warning.main\">\n                    {gateways.filter(gw => getGatewayStatusSummary(gw).status === 'pending').length}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Pending\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ textAlign: 'center' }}>\n                  <Typography variant=\"h4\" color=\"error.main\">\n                    {gateways.filter(gw => getGatewayStatusSummary(gw).status === 'failed').length}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Failed\n                  </Typography>\n                </Box>\n              </Grid>\n            </Grid>\n          </Paper>\n\n          {/* Gateway List */}\n          {gateways.length === 0 ? (\n            <Paper sx={{ p: 4, textAlign: 'center' }}>\n              <Typography variant=\"h6\" color=\"text.secondary\" gutterBottom>\n                No Gateways Found\n              </Typography>\n              <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mb: 3 }}>\n                Create your first Gateway to start routing traffic through Envoy Gateway.\n              </Typography>\n              <Button\n                variant=\"contained\"\n                startIcon={<AddIcon />}\n                onClick={() => setShowCreateForm(true)}\n              >\n                Create Gateway\n              </Button>\n            </Paper>\n          ) : (\n            <Box>\n              <Typography variant=\"h6\" gutterBottom>\n                Gateways ({gateways.length})\n              </Typography>\n              {gateways.map((gateway) => (\n                <GatewayStatusMonitor\n                  key={`${gateway.metadata.namespace}-${gateway.metadata.name}`}\n                  gatewayName={gateway.metadata.name}\n                  namespace={gateway.metadata.namespace}\n                  onDelete={handleGatewayDeleted}\n                />\n              ))}\n            </Box>\n          )}\n        </>\n      )}\n\n      {/* Create Gateway Dialog */}\n      <Dialog\n        open={showCreateForm}\n        onClose={() => setShowCreateForm(false)}\n        maxWidth=\"md\"\n        fullWidth\n        PaperProps={{\n          sx: { minHeight: '80vh' }\n        }}\n      >\n        <DialogTitle>\n          Create New Gateway\n        </DialogTitle>\n        <DialogContent sx={{ p: 0 }}>\n          <GatewayCreationForm\n            onSuccess={handleCreateSuccess}\n            onCancel={() => setShowCreateForm(false)}\n          />\n        </DialogContent>\n      </Dialog>\n    </Box>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/components/DeploymentStatusMonitor.tsx",["146"],[],"import React, { useState, useEffect } from 'react';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Divider,\n  CircularProgress,\n  Button,\n  Collapse,\n  IconButton,\n  Chip,\n  Tooltip\n} from '@mui/material';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport RefreshIcon from '@mui/icons-material/Refresh';\nimport CheckCircleIcon from '@mui/icons-material/CheckCircle';\nimport ErrorIcon from '@mui/icons-material/Error';\nimport WarningIcon from '@mui/icons-material/Warning';\nimport { getDetailedDeploymentStatus, getPodDetails, getServiceEndpoints } from '../helper/kubernetes';\nimport { PodStatusIndicator } from './PodStatusIndicator';\nimport { DeploymentTroubleshooter } from './DeploymentTroubleshooter';\n\ninterface DeploymentStatusMonitorProps {\n  ddClient: any;\n  namespace: string;\n  deploymentName: string;\n  serviceName?: string;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\nexport const DeploymentStatusMonitor: React.FC<DeploymentStatusMonitorProps> = ({\n  ddClient,\n  namespace,\n  deploymentName,\n  serviceName,\n  autoRefresh = true,\n  refreshInterval = 5000\n}) => {\n  const [deploymentStatus, setDeploymentStatus] = useState<any>(null);\n  const [podDetails, setPodDetails] = useState<any[]>([]);\n  const [serviceInfo, setServiceInfo] = useState<any>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [expanded, setExpanded] = useState<boolean>(false);\n  const [refreshTimer, setRefreshTimer] = useState<NodeJS.Timeout | null>(null);\n  const [lastRefreshed, setLastRefreshed] = useState<Date>(new Date());\n\n  const fetchStatus = async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      // Get detailed deployment status\n      const status = await getDetailedDeploymentStatus(ddClient, namespace, deploymentName);\n      setDeploymentStatus(status);\n      \n      // Get pod details if deployment exists\n      if (status && status.status !== 'not_found') {\n        const pods = await getPodDetails(ddClient, namespace, `app=${deploymentName}`);\n        setPodDetails(pods);\n        \n        // Get service info if service name is provided\n        if (serviceName) {\n          const svcInfo = await getServiceEndpoints(ddClient, namespace, serviceName);\n          setServiceInfo(svcInfo);\n        }\n      } else {\n        setPodDetails([]);\n        setServiceInfo(null);\n      }\n      \n      setLastRefreshed(new Date());\n    } catch (err: any) {\n      console.error('Error fetching deployment status:', err);\n      setError(typeof err === 'string' ? err : JSON.stringify(err, null, 2));\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Initial fetch\n  useEffect(() => {\n    fetchStatus();\n    \n    // Setup auto-refresh if enabled\n    if (autoRefresh) {\n      const timer = setInterval(fetchStatus, refreshInterval);\n      setRefreshTimer(timer);\n    }\n    \n    return () => {\n      if (refreshTimer) {\n        clearInterval(refreshTimer);\n      }\n    };\n  }, [namespace, deploymentName, serviceName, autoRefresh, refreshInterval]);\n\n  const handleRefresh = () => {\n    fetchStatus();\n  };\n\n  const handleToggleExpand = () => {\n    setExpanded(!expanded);\n  };\n\n  const getStatusIcon = (status: string) => {\n    switch (status) {\n      case 'ready':\n        return <CheckCircleIcon fontSize=\"small\" color=\"success\" />;\n      case 'pending':\n        return <WarningIcon fontSize=\"small\" color=\"warning\" />;\n      case 'failed':\n      case 'not_found':\n        return <ErrorIcon fontSize=\"small\" color=\"error\" />;\n      default:\n        return null;\n    }\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'ready':\n        return 'success';\n      case 'pending':\n        return 'warning';\n      case 'failed':\n      case 'not_found':\n        return 'error';\n      default:\n        return 'default';\n    }\n  };\n\n  if (loading && !deploymentStatus) {\n    return (\n      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', p: 2 }}>\n        <CircularProgress size={24} sx={{ mr: 1 }} />\n        <Typography>Loading deployment status...</Typography>\n      </Box>\n    );\n  }\n\n  if (error) {\n    return (\n      <Paper variant=\"outlined\" sx={{ p: 2, bgcolor: 'error.light', color: 'error.contrastText' }}>\n        <Typography variant=\"subtitle1\">Error fetching deployment status</Typography>\n        <Typography variant=\"body2\">{error}</Typography>\n        <Button \n          variant=\"contained\" \n          size=\"small\" \n          onClick={handleRefresh}\n          sx={{ mt: 1 }}\n        >\n          Retry\n        </Button>\n      </Paper>\n    );\n  }\n\n  if (!deploymentStatus || deploymentStatus.status === 'not_found') {\n    return (\n      <Paper variant=\"outlined\" sx={{ p: 2 }}>\n        <Typography variant=\"subtitle1\">\n          Deployment not found: {deploymentName}\n        </Typography>\n        <Typography variant=\"body2\" color=\"text.secondary\">\n          The deployment may have been deleted or has not been created yet.\n        </Typography>\n        <Button \n          variant=\"outlined\" \n          size=\"small\" \n          onClick={handleRefresh}\n          startIcon={<RefreshIcon />}\n          sx={{ mt: 1 }}\n        >\n          Refresh\n        </Button>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper variant=\"outlined\" sx={{ mb: 2 }}>\n      <Box sx={{ p: 2 }}>\n        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n          <Box sx={{ display: 'flex', alignItems: 'center' }}>\n            {getStatusIcon(deploymentStatus.status)}\n            <Typography variant=\"h6\" sx={{ ml: 1 }}>\n              {deploymentName}\n            </Typography>\n            <Chip \n              label={deploymentStatus.status.toUpperCase()} \n              size=\"small\" \n              color={getStatusColor(deploymentStatus.status) as any} \n              variant=\"outlined\" \n              sx={{ ml: 2 }}\n            />\n          </Box>\n          <Box>\n            <Tooltip title={`Last refreshed: ${lastRefreshed.toLocaleTimeString()}`}>\n              <IconButton size=\"small\" onClick={handleRefresh} disabled={loading}>\n                {loading ? <CircularProgress size={18} /> : <RefreshIcon />}\n              </IconButton>\n            </Tooltip>\n            <IconButton \n              size=\"small\" \n              onClick={handleToggleExpand}\n              sx={{ \n                transform: expanded ? 'rotate(180deg)' : 'rotate(0deg)', \n                transition: 'transform 0.2s' \n              }}\n            >\n              <ExpandMoreIcon />\n            </IconButton>\n          </Box>\n        </Box>\n        \n        <Box sx={{ mt: 1 }}>\n          <Typography variant=\"body2\">\n            Namespace: <strong>{namespace}</strong>\n          </Typography>\n          <Typography variant=\"body2\">\n            Replicas: <strong>{deploymentStatus.readyReplicas}/{deploymentStatus.desiredReplicas}</strong>\n            {deploymentStatus.age && `  Age: ${deploymentStatus.age}`}\n          </Typography>\n          {deploymentStatus.message && (\n            <Typography \n              variant=\"body2\" \n              color={deploymentStatus.status === 'ready' ? 'success.main' : 'text.secondary'}\n              sx={{ mt: 0.5 }}\n            >\n              {deploymentStatus.message}\n            </Typography>\n          )}\n        </Box>\n      </Box>\n      \n      <Collapse in={expanded}>\n        <Divider />\n        <Box sx={{ p: 2 }}>\n          <Typography variant=\"subtitle1\" gutterBottom>\n            Pod Status {podDetails.length > 0 && `(${podDetails.length})`}\n          </Typography>\n          \n          {podDetails.length === 0 ? (\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              No pods found for this deployment.\n            </Typography>\n          ) : (\n            <Box>\n              {podDetails.map((pod, index) => (\n                <PodStatusIndicator key={index} pod={pod} />\n              ))}\n            </Box>\n          )}\n          \n          {serviceInfo && serviceInfo.found && (\n            <>\n              <Divider sx={{ my: 2 }} />\n              <Typography variant=\"subtitle1\" gutterBottom>\n                Service Endpoints\n              </Typography>\n              \n              {serviceInfo.endpoints && serviceInfo.endpoints.length > 0 ? (\n                <Box>\n                  <Typography variant=\"body2\" gutterBottom>\n                    Service <strong>{serviceName}</strong> has the following endpoints:\n                  </Typography>\n                  <Paper variant=\"outlined\" sx={{ p: 1, bgcolor: 'background.default' }}>\n                    {serviceInfo.endpoints.map((endpoint: string, index: number) => (\n                      <Typography key={index} variant=\"body2\" component=\"div\" fontFamily=\"monospace\">\n                        {endpoint}\n                      </Typography>\n                    ))}\n                  </Paper>\n                </Box>\n              ) : (\n                <Typography variant=\"body2\" color=\"text.secondary\">\n                  Service <strong>{serviceName}</strong> has no endpoints.\n                </Typography>\n              )}\n            </>\n          )}\n          \n          {deploymentStatus.status !== 'ready' && (\n            <>\n              <Divider sx={{ my: 2 }} />\n              <DeploymentTroubleshooter \n                deploymentStatus={deploymentStatus} \n                podDetails={podDetails} \n              />\n            </>\n          )}\n        </Box>\n      </Collapse>\n    </Paper>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/components/HTTPClient.tsx",["147","148","149","150","151","152"],[],"import React, { useState, useEffect } from 'react';\nimport {\n  Box,\n  Typography,\n  TextField,\n  Button,\n  Paper,\n  Grid,\n  FormControl,\n  InputLabel,\n  Select,\n  MenuItem,\n  Tabs,\n  Tab,\n  Alert,\n  CircularProgress,\n  Divider,\n  IconButton,\n  Tooltip\n} from '@mui/material';\nimport SendIcon from '@mui/icons-material/Send';\nimport ClearIcon from '@mui/icons-material/Clear';\nimport HistoryIcon from '@mui/icons-material/History';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport { createDockerDesktopClient } from \"@docker/extension-api-client\";\nimport {\n  HTTPClientState,\n  HTTPMethod,\n  HTTP_METHODS,\n  DEFAULT_HTTP_CLIENT_STATE,\n  HeaderPair,\n  TestResult\n} from '../types/httpClient';\nimport { HTTPClientService } from '../services/httpClientService';\nimport { HTTPResponseDisplay } from './HTTPResponseDisplay';\nimport { HTTPRequestHistory } from './HTTPRequestHistory';\nimport { CurlCommandDisplay } from './CurlCommandDisplay';\nimport { generateFormattedCurlCommand } from '../utils/curlGenerator';\n\nconst ddClient = createDockerDesktopClient();\n\ninterface HTTPClientProps {\n  initialUrl?: string;\n  initialMethod?: HTTPMethod;\n  onRequestComplete?: (result: TestResult) => void;\n  compact?: boolean;\n  proxyUrl?: string; // URL from proxy manager\n}\n\ninterface TabPanelProps {\n  children?: React.ReactNode;\n  index: number;\n  value: number;\n}\n\nconst TabPanel: React.FC<TabPanelProps> = ({ children, value, index }) => (\n  <div hidden={value !== index} style={{ paddingTop: 16 }}>\n    {value === index && children}\n  </div>\n);\n\nexport const HTTPClient: React.FC<HTTPClientProps> = ({\n  initialUrl = '',\n  initialMethod = 'GET',\n  onRequestComplete,\n  compact = false,\n  proxyUrl\n}) => {\n  const [state, setState] = useState<HTTPClientState>({\n    ...DEFAULT_HTTP_CLIENT_STATE,\n    url: initialUrl,\n    method: initialMethod\n  });\n  const [activeTab, setActiveTab] = useState(0);\n  const [httpService] = useState(() => new HTTPClientService(ddClient));\n\n  useEffect(() => {\n    if (initialUrl) {\n      setState(prev => ({ ...prev, url: initialUrl }));\n    }\n  }, [initialUrl]);\n\n  // Handle proxy URL updates\n  useEffect(() => {\n    if (proxyUrl) {\n      setState(prev => ({ ...prev, url: proxyUrl }));\n    }\n  }, [proxyUrl]);\n\n  const handleMethodChange = (method: HTTPMethod) => {\n    setState(prev => ({ ...prev, method }));\n  };\n\n  const handleUrlChange = (url: string) => {\n    setState(prev => ({ ...prev, url }));\n  };\n\n  const handleBodyChange = (body: string) => {\n    setState(prev => ({ ...prev, body }));\n  };\n\n  const handleHeaderChange = (index: number, field: keyof HeaderPair, value: string | boolean) => {\n    setState(prev => ({\n      ...prev,\n      headers: prev.headers.map((header, i) =>\n        i === index ? { ...header, [field]: value } : header\n      )\n    }));\n  };\n\n  const addHeader = () => {\n    setState(prev => ({\n      ...prev,\n      headers: [...prev.headers, { key: '', value: '', enabled: true }]\n    }));\n  };\n\n  const removeHeader = (index: number) => {\n    setState(prev => ({\n      ...prev,\n      headers: prev.headers.filter((_, i) => i !== index)\n    }));\n  };\n\n  const handleSendRequest = async () => {\n    if (!state.url.trim()) {\n      setState(prev => ({ ...prev, error: 'URL is required' }));\n      return;\n    }\n\n    setState(prev => ({\n      ...prev,\n      loading: true,\n      error: null,\n      response: null\n    }));\n\n    try {\n      const headers = HTTPClientService.headerPairsToObject(state.headers);\n\n      const request = {\n        method: state.method,\n        url: state.url.trim(),\n        headers,\n        body: state.body || undefined\n      };\n\n      const result = await httpService.makeRequest(request);\n\n      setState(prev => ({\n        ...prev,\n        loading: false,\n        response: result.response || null,\n        error: result.error || null,\n        history: [result, ...prev.history.slice(0, 49)] // Keep last 50 requests\n      }));\n\n      // Switch to response tab if request was successful\n      if (result.response && !result.error) {\n        setActiveTab(1);\n      }\n\n      // Notify parent component\n      onRequestComplete?.(result);\n\n    } catch (error: any) {\n      setState(prev => ({\n        ...prev,\n        loading: false,\n        error: typeof error === 'string' ? error : error.message || 'Request failed'\n      }));\n    }\n  };\n\n  const handleClearForm = () => {\n    setState({\n      ...DEFAULT_HTTP_CLIENT_STATE,\n      url: initialUrl,\n      method: initialMethod\n    });\n    setActiveTab(0);\n  };\n\n  const handleCopyAsCurl = async () => {\n    const headers = HTTPClientService.headerPairsToObject(state.headers);\n    const request = {\n      method: state.method,\n      url: state.url,\n      headers,\n      body: state.body || undefined\n    };\n\n    const curlCommand = generateFormattedCurlCommand(request);\n\n    try {\n      await navigator.clipboard.writeText(curlCommand);\n      // Could add a toast notification here\n    } catch (error) {\n      console.error('Failed to copy to clipboard:', error);\n    }\n  };\n\n  const handleReplayRequest = (result: TestResult) => {\n    setState(prev => ({\n      ...prev,\n      method: result.request.method,\n      url: result.request.url,\n      headers: Object.entries(result.request.headers).map(([key, value]) => ({\n        key,\n        value,\n        enabled: true\n      })),\n      body: result.request.body || ''\n    }));\n    setActiveTab(0);\n  };\n\n  const currentCurlCommand = (() => {\n    const headers = HTTPClientService.headerPairsToObject(state.headers);\n    return generateFormattedCurlCommand({\n      method: state.method,\n      url: state.url,\n      headers,\n      body: state.body || undefined\n    });\n  })();\n\n  return (\n    <Paper\n      elevation={compact ? 1 : 2}\n      sx={{\n        p: compact ? 2 : 3,\n        backgroundColor: 'background.paper',\n        border: '1px solid',\n        borderColor: 'divider'\n      }}\n    >\n      <Box sx={{ mb: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n        <Typography variant={compact ? \"h6\" : \"h5\"} component=\"h2\">\n          HTTP Client\n        </Typography>\n        <Box>\n          <Tooltip title=\"Copy as cURL\">\n            <IconButton onClick={handleCopyAsCurl} size=\"small\">\n              <ContentCopyIcon />\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Clear form\">\n            <IconButton onClick={handleClearForm} size=\"small\">\n              <ClearIcon />\n            </IconButton>\n          </Tooltip>\n        </Box>\n      </Box>\n\n      <Tabs\n        value={activeTab}\n        onChange={(_, newValue) => setActiveTab(newValue)}\n        sx={{ mb: 2, borderBottom: 1, borderColor: 'divider' }}\n      >\n        <Tab label=\"Request\" />\n        <Tab label=\"Response\" />\n        <Tab label=\"History\" />\n        <Tab label=\"cURL\" />\n      </Tabs>\n\n      <TabPanel value={activeTab} index={0}>\n        <Grid container spacing={2}>\n          {/* Method and URL */}\n          <Grid item xs={12} md={3}>\n            <FormControl fullWidth size=\"small\">\n              <InputLabel>Method</InputLabel>\n              <Select\n                value={state.method}\n                label=\"Method\"\n                onChange={(e) => handleMethodChange(e.target.value as HTTPMethod)}\n                sx={{\n                  '& .MuiOutlinedInput-notchedOutline': {\n                    borderColor: 'rgba(255, 255, 255, 0.23)'\n                  },\n                  '&:hover .MuiOutlinedInput-notchedOutline': {\n                    borderColor: 'rgba(255, 255, 255, 0.5)'\n                  },\n                  '&.Mui-focused .MuiOutlinedInput-notchedOutline': {\n                    borderColor: 'primary.main'\n                  }\n                }}\n              >\n                {HTTP_METHODS.map(method => (\n                  <MenuItem key={method} value={method}>{method}</MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n          </Grid>\n\n          <Grid item xs={12} md={7}>\n            <TextField\n              fullWidth\n              size=\"small\"\n              label=\"URL\"\n              value={state.url}\n              onChange={(e) => handleUrlChange(e.target.value)}\n              placeholder=\"https://api.example.com/endpoint\"\n              sx={{\n                '& .MuiOutlinedInput-root': {\n                  '& fieldset': {\n                    borderColor: 'rgba(255, 255, 255, 0.23)'\n                  },\n                  '&:hover fieldset': {\n                    borderColor: 'rgba(255, 255, 255, 0.5)'\n                  },\n                  '&.Mui-focused fieldset': {\n                    borderColor: 'primary.main'\n                  }\n                }\n              }}\n            />\n          </Grid>\n\n          <Grid item xs={12} md={2}>\n            <Button\n              fullWidth\n              variant=\"contained\"\n              onClick={handleSendRequest}\n              disabled={state.loading || !state.url.trim()}\n              startIcon={state.loading ? <CircularProgress size={16} /> : <SendIcon />}\n              sx={{ height: '40px' }}\n            >\n              {state.loading ? 'Sending...' : 'Send'}\n            </Button>\n          </Grid>\n        </Grid>\n\n        {state.error && (\n          <Alert severity=\"error\" sx={{ mt: 2 }}>\n            {state.error}\n          </Alert>\n        )}\n      </TabPanel>\n\n      <TabPanel value={activeTab} index={1}>\n        {state.response ? (\n          <HTTPResponseDisplay response={state.response} />\n        ) : (\n          <Typography color=\"text.secondary\" sx={{ textAlign: 'center', py: 4 }}>\n            No response yet. Send a request to see the response here.\n          </Typography>\n        )}\n      </TabPanel>\n\n      <TabPanel value={activeTab} index={2}>\n        <HTTPRequestHistory\n          history={state.history}\n          onReplay={handleReplayRequest}\n          onClear={() => setState(prev => ({ ...prev, history: [] }))}\n        />\n      </TabPanel>\n\n      <TabPanel value={activeTab} index={3}>\n        <CurlCommandDisplay\n          curlCommand={currentCurlCommand}\n          request={{\n            method: state.method,\n            url: state.url,\n            headers: HTTPClientService.headerPairsToObject(state.headers),\n            body: state.body || undefined\n          }}\n        />\n      </TabPanel>\n    </Paper>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/components/ProxyManager.tsx",["153","154","155","156","157","158"],[],"import React, { useState, useEffect } from 'react';\nimport {\n  Box,\n  Typography,\n  Button,\n  Paper,\n  Grid,\n  Chip,\n  Alert,\n  CircularProgress,\n  TextField,\n  FormControl,\n  InputLabel,\n  Select,\n  MenuItem,\n  IconButton,\n  Tooltip,\n  Divider,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemSecondaryAction\n} from '@mui/material';\nimport PlayArrowIcon from '@mui/icons-material/PlayArrow';\nimport StopIcon from '@mui/icons-material/Stop';\nimport RefreshIcon from '@mui/icons-material/Refresh';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport LinkIcon from '@mui/icons-material/Link';\nimport CheckCircleIcon from '@mui/icons-material/CheckCircle';\nimport ErrorIcon from '@mui/icons-material/Error';\nimport { createDockerDesktopClient } from \"@docker/extension-api-client\";\nimport { KubectlProxyService, ProxyStatus, ServiceEndpoint } from '../services/kubectlProxyService';\n\nconst ddClient = createDockerDesktopClient();\n\ninterface ProxyManagerProps {\n  onProxyStatusChange?: (status: ProxyStatus) => void;\n  onUrlGenerated?: (url: string) => void;\n}\n\nexport const ProxyManager: React.FC<ProxyManagerProps> = ({\n  onProxyStatusChange,\n  onUrlGenerated\n}) => {\n  const [proxyService] = useState(() => new KubectlProxyService(ddClient));\n  const [proxyStatus, setProxyStatus] = useState<ProxyStatus>({ isRunning: false, port: 8001 });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [success, setSuccess] = useState<string | null>(null);\n\n  // URL Generator state\n  const [serviceName, setServiceName] = useState('echo-service');\n  const [namespace, setNamespace] = useState('demo');\n  const [port, setPort] = useState(8080);\n  const [path, setPath] = useState('/');\n  const [generatedUrl, setGeneratedUrl] = useState('');\n\n  useEffect(() => {\n    // Initial status check\n    checkStatus();\n\n    // Cleanup on unmount\n    return () => {\n      proxyService.destroy();\n    };\n  }, [proxyService]);\n\n  useEffect(() => {\n    onProxyStatusChange?.(proxyStatus);\n  }, [proxyStatus, onProxyStatusChange]);\n\n  const checkStatus = async () => {\n    try {\n      const status = await proxyService.checkProxyStatus();\n      setProxyStatus(status);\n      setError(status.error || null);\n    } catch (error: any) {\n      setError(typeof error === 'string' ? error : error.message || 'Failed to check proxy status');\n    }\n  };\n\n  const handleStartProxy = async () => {\n    setIsLoading(true);\n    setError(null);\n    setSuccess(null);\n\n    try {\n      const status = await proxyService.startProxy();\n      setProxyStatus(status);\n\n      if (status.isRunning) {\n        setSuccess('Kubectl proxy started successfully!');\n        // Generate URL for current service selection\n        updateGeneratedUrl();\n      } else {\n        setError(status.error || 'Failed to start proxy');\n      }\n    } catch (error: any) {\n      setError(typeof error === 'string' ? error : error.message || 'Failed to start proxy');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleStopProxy = async () => {\n    setIsLoading(true);\n    setError(null);\n    setSuccess(null);\n\n    try {\n      await proxyService.stopProxy();\n      const status = proxyService.getProxyStatus();\n      setProxyStatus(status);\n      setSuccess('Kubectl proxy stopped successfully!');\n      setGeneratedUrl('');\n    } catch (error: any) {\n      setError(typeof error === 'string' ? error : error.message || 'Failed to stop proxy');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleTestConnectivity = async () => {\n    setIsLoading(true);\n    setError(null);\n    setSuccess(null);\n\n    try {\n      const result = await proxyService.testProxyConnectivity();\n      if (result.success) {\n        setSuccess(result.message);\n      } else {\n        setError(result.message);\n      }\n    } catch (error: any) {\n      setError(typeof error === 'string' ? error : error.message || 'Connectivity test failed');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const updateGeneratedUrl = () => {\n    if (proxyStatus.isRunning && serviceName && namespace && port) {\n      const url = proxyService.generateProxyUrl(serviceName, namespace, port, path);\n      setGeneratedUrl(url);\n    } else {\n      setGeneratedUrl('');\n    }\n  };\n\n  useEffect(() => {\n    updateGeneratedUrl();\n  }, [serviceName, namespace, port, path, proxyStatus.isRunning]);\n\n  const handleCopyUrl = async (url: string) => {\n    try {\n      await navigator.clipboard.writeText(url);\n      setSuccess('URL copied to clipboard!');\n    } catch (error) {\n      setError('Failed to copy URL to clipboard');\n    }\n  };\n\n  const handleUseUrl = (url: string) => {\n    onUrlGenerated?.(url);\n    setSuccess('URL sent to HTTP client!');\n  };\n\n  const handleQuickService = (endpoint: ServiceEndpoint) => {\n    setServiceName(endpoint.serviceName);\n    setNamespace(endpoint.namespace);\n    setPort(endpoint.port);\n    setPath(endpoint.path || '/');\n  };\n\n  const getStatusColor = (): 'success' | 'error' | 'warning' | 'default' => {\n    if (proxyStatus.isRunning) return 'success';\n    if (proxyStatus.error) return 'error';\n    return 'default';\n  };\n\n  const getStatusIcon = () => {\n    if (proxyStatus.isRunning) return <CheckCircleIcon />;\n    if (proxyStatus.error) return <ErrorIcon />;\n    return null;\n  };\n\n  const commonEndpoints = proxyService.getCommonServiceEndpoints();\n\n  return (\n    <Paper elevation={2} sx={{ p: 3, mb: 3 }}>\n      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>\n        <Typography variant=\"h6\" component=\"h3\">\n          Kubectl Proxy Manager\n        </Typography>\n        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n          <Chip\n            label={proxyStatus.isRunning ? 'Running' : 'Stopped'}\n            color={getStatusColor()}\n            icon={getStatusIcon() || undefined}\n            size=\"small\"\n          />\n          <Tooltip title=\"Refresh status\">\n            <IconButton onClick={checkStatus} size=\"small\">\n              <RefreshIcon />\n            </IconButton>\n          </Tooltip>\n        </Box>\n      </Box>\n\n      <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mb: 3 }}>\n        Kubectl proxy provides access to Kubernetes services through a local HTTP proxy.\n        Start the proxy to test services without manual port forwarding.\n      </Typography>\n\n      {/* Status and Controls */}\n      <Grid container spacing={2} sx={{ mb: 3 }}>\n        <Grid item xs={12} md={6}>\n          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>\n            <Button\n              variant=\"contained\"\n              color={proxyStatus.isRunning ? \"error\" : \"primary\"}\n              onClick={proxyStatus.isRunning ? handleStopProxy : handleStartProxy}\n              disabled={isLoading}\n              startIcon={\n                isLoading ? (\n                  <CircularProgress size={16} />\n                ) : proxyStatus.isRunning ? (\n                  <StopIcon />\n                ) : (\n                  <PlayArrowIcon />\n                )\n              }\n            >\n              {isLoading\n                ? 'Working...'\n                : proxyStatus.isRunning\n                ? 'Stop Proxy'\n                : 'Start Proxy'}\n            </Button>\n\n            {proxyStatus.isRunning && (\n              <Button\n                variant=\"outlined\"\n                onClick={handleTestConnectivity}\n                disabled={isLoading}\n              >\n                Test Connection\n              </Button>\n            )}\n          </Box>\n        </Grid>\n\n        <Grid item xs={12} md={6}>\n          {proxyStatus.isRunning && (\n            <Box>\n              <Typography variant=\"caption\" color=\"text.secondary\">\n                Proxy URL: http://localhost:{proxyStatus.port}\n              </Typography>\n              {proxyStatus.startTime && (\n                <Typography variant=\"caption\" color=\"text.secondary\" sx={{ display: 'block' }}>\n                  Started: {proxyStatus.startTime.toLocaleTimeString()}\n                </Typography>\n              )}\n            </Box>\n          )}\n        </Grid>\n      </Grid>\n\n      {/* Error/Success Messages */}\n      {error && (\n        <Alert severity=\"error\" sx={{ mb: 2 }} onClose={() => setError(null)}>\n          {error}\n        </Alert>\n      )}\n\n      {success && (\n        <Alert severity=\"success\" sx={{ mb: 2 }} onClose={() => setSuccess(null)}>\n          {success}\n        </Alert>\n      )}\n\n      {/* URL Generator */}\n      {proxyStatus.isRunning && (\n        <>\n          <Divider sx={{ my: 2 }} />\n          <Typography variant=\"subtitle1\" gutterBottom>\n            Service URL Generator\n          </Typography>\n\n          <Grid container spacing={2} sx={{ mb: 2 }}>\n            <Grid item xs={12} md={3}>\n              <TextField\n                fullWidth\n                size=\"small\"\n                label=\"Service Name\"\n                value={serviceName}\n                onChange={(e) => setServiceName(e.target.value)}\n              />\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <TextField\n                fullWidth\n                size=\"small\"\n                label=\"Namespace\"\n                value={namespace}\n                onChange={(e) => setNamespace(e.target.value)}\n              />\n            </Grid>\n            <Grid item xs={12} md={2}>\n              <TextField\n                fullWidth\n                size=\"small\"\n                label=\"Port\"\n                type=\"number\"\n                value={port}\n                onChange={(e) => setPort(parseInt(e.target.value) || 8080)}\n              />\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <TextField\n                fullWidth\n                size=\"small\"\n                label=\"Path\"\n                value={path}\n                onChange={(e) => setPath(e.target.value)}\n                placeholder=\"/\"\n              />\n            </Grid>\n          </Grid>\n\n          {generatedUrl && (\n            <Box sx={{ mb: 2 }}>\n              <TextField\n                fullWidth\n                size=\"small\"\n                label=\"Generated Proxy URL\"\n                value={generatedUrl}\n                InputProps={{\n                  readOnly: true,\n                  endAdornment: (\n                    <Box sx={{ display: 'flex', gap: 1 }}>\n                      <Tooltip title=\"Copy URL\">\n                        <IconButton onClick={() => handleCopyUrl(generatedUrl)} size=\"small\">\n                          <ContentCopyIcon />\n                        </IconButton>\n                      </Tooltip>\n                      <Tooltip title=\"Use in HTTP Client\">\n                        <IconButton onClick={() => handleUseUrl(generatedUrl)} size=\"small\">\n                          <LinkIcon />\n                        </IconButton>\n                      </Tooltip>\n                    </Box>\n                  )\n                }}\n              />\n            </Box>\n          )}\n\n          {/* Quick Access to Common Services */}\n          <Typography variant=\"subtitle2\" gutterBottom>\n            Quick Access:\n          </Typography>\n          <List dense>\n            {commonEndpoints.map((endpoint, index) => {\n              const url = proxyService.generateProxyUrlFromEndpoint(endpoint);\n              return (\n                <ListItem key={index} divider>\n                  <ListItemText\n                    primary={`${endpoint.serviceName}.${endpoint.namespace}`}\n                    secondary={`Port ${endpoint.port}  ${url}`}\n                  />\n                  <ListItemSecondaryAction>\n                    <Tooltip title=\"Use this service\">\n                      <IconButton\n                        onClick={() => handleQuickService(endpoint)}\n                        size=\"small\"\n                      >\n                        <LinkIcon />\n                      </IconButton>\n                    </Tooltip>\n                    <Tooltip title=\"Copy URL\">\n                      <IconButton\n                        onClick={() => handleCopyUrl(url)}\n                        size=\"small\"\n                      >\n                        <ContentCopyIcon />\n                      </IconButton>\n                    </Tooltip>\n                  </ListItemSecondaryAction>\n                </ListItem>\n              );\n            })}\n          </List>\n        </>\n      )}\n    </Paper>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/services/httpClientService.ts",[],[],"/Users/saptak/code/envddext/ui/src/components/GatewayCreationForm.tsx",[],[],"/Users/saptak/code/envddext/ui/src/components/LoadBalancerManager.tsx",["159"],[],"import React, { useState, useEffect } from 'react';\nimport {\n  Box,\n  Card,\n  CardContent,\n  Typography,\n  Button,\n  Alert,\n  AlertTitle,\n  CircularProgress,\n  Chip,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemIcon,\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  TextField,\n  FormControlLabel,\n  Switch,\n  Divider,\n  LinearProgress\n} from '@mui/material';\nimport {\n  CheckCircle as CheckCircleIcon,\n  Warning as WarningIcon,\n  Error as ErrorIcon,\n  Cloud as CloudIcon,\n  Settings as SettingsIcon,\n  NetworkCheck as NetworkCheckIcon,\n  Router as RouterIcon\n} from '@mui/icons-material';\nimport { createDockerDesktopClient } from \"@docker/extension-api-client\";\nimport { LoadBalancerService, LoadBalancerStatus, LoadBalancerConfiguration } from '../services/loadBalancerService';\n\nconst ddClient = createDockerDesktopClient();\nconst loadBalancerService = new LoadBalancerService(ddClient);\n\ninterface LoadBalancerManagerProps {\n  onStatusChange?: (status: LoadBalancerStatus) => void;\n  showConfigureButton?: boolean;\n}\n\nexport const LoadBalancerManager: React.FC<LoadBalancerManagerProps> = ({\n  onStatusChange,\n  showConfigureButton = true\n}) => {\n  const [status, setStatus] = useState<LoadBalancerStatus | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [configuring, setConfiguring] = useState(false);\n  const [showConfigDialog, setShowConfigDialog] = useState(false);\n  const [config, setConfig] = useState<LoadBalancerConfiguration>({\n    provider: 'metallb',\n    ipRange: '172.18.200.1-172.18.200.100',\n    autoDetectRange: true\n  });\n\n  useEffect(() => {\n    checkStatus();\n  }, []);\n\n  const checkStatus = async () => {\n    try {\n      setLoading(true);\n      const result = await loadBalancerService.checkLoadBalancerStatus();\n      setStatus(result);\n      onStatusChange?.(result);\n    } catch (error) {\n      console.error('Error checking LoadBalancer status:', error);\n      const errorStatus = {\n        isConfigured: false,\n        error: 'Failed to check LoadBalancer status'\n      };\n      setStatus(errorStatus);\n      onStatusChange?.(errorStatus);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleConfigure = async () => {\n    try {\n      setConfiguring(true);\n      const result = await loadBalancerService.configureMetalLB(config);\n      \n      if (result.success) {\n        // Wait a moment and check status again\n        setTimeout(() => {\n          checkStatus();\n        }, 2000);\n        setShowConfigDialog(false);\n      } else {\n        console.error('Failed to configure LoadBalancer:', result.error);\n        // Update status with error\n        setStatus(prev => ({\n          ...prev,\n          isConfigured: false,\n          error: result.error\n        }));\n      }\n    } catch (error: any) {\n      console.error('Error configuring LoadBalancer:', error);\n      setStatus(prev => ({\n        ...prev,\n        isConfigured: false,\n        error: typeof error === 'string' ? error : error.message\n      }));\n    } finally {\n      setConfiguring(false);\n    }\n  };\n\n  const handleRemove = async () => {\n    try {\n      setConfiguring(true);\n      const result = await loadBalancerService.removeMetalLB();\n      \n      if (result.success) {\n        setTimeout(() => {\n          checkStatus();\n        }, 2000);\n      } else {\n        console.error('Failed to remove LoadBalancer:', result.error);\n      }\n    } catch (error: any) {\n      console.error('Error removing LoadBalancer:', error);\n    } finally {\n      setConfiguring(false);\n    }\n  };\n\n  const getStatusIcon = () => {\n    if (loading) return <CircularProgress size={20} />;\n    if (!status) return <ErrorIcon color=\"error\" />;\n    \n    if (status.isConfigured) {\n      return <CheckCircleIcon color=\"success\" />;\n    } else {\n      return <WarningIcon color=\"warning\" />;\n    }\n  };\n\n  const getStatusColor = () => {\n    if (!status || loading) return 'default';\n    return status.isConfigured ? 'success' : 'warning';\n  };\n\n  const getProviderIcon = () => {\n    if (!status?.provider) return <RouterIcon />;\n    \n    switch (status.provider) {\n      case 'metallb':\n        return <RouterIcon />;\n      case 'cloud':\n        return <CloudIcon />;\n      default:\n        return <NetworkCheckIcon />;\n    }\n  };\n\n  if (loading && !status) {\n    return (\n      <Card>\n        <CardContent>\n          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>\n            <CircularProgress size={24} />\n            <Typography>Checking LoadBalancer status...</Typography>\n          </Box>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return (\n    <Box>\n      <Card>\n        <CardContent>\n          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>\n            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>\n              {getStatusIcon()}\n              <Typography variant=\"h6\">\n                LoadBalancer Configuration\n              </Typography>\n              <Chip\n                label={status?.isConfigured ? 'Configured' : 'Not Configured'}\n                color={getStatusColor() as any}\n                size=\"small\"\n              />\n            </Box>\n            <Button\n              startIcon={<SettingsIcon />}\n              onClick={checkStatus}\n              disabled={loading}\n              size=\"small\"\n            >\n              Refresh\n            </Button>\n          </Box>\n\n          {status?.error && (\n            <Alert severity=\"error\" sx={{ mb: 2 }}>\n              <AlertTitle>LoadBalancer Status Error</AlertTitle>\n              {status.error}\n            </Alert>\n          )}\n\n          {!status?.isConfigured && !status?.error && (\n            <Alert severity=\"warning\" sx={{ mb: 2 }}>\n              <AlertTitle>LoadBalancer Not Configured</AlertTitle>\n              No LoadBalancer controller detected. Gateways will not receive external IP addresses.\n              {showConfigureButton && (\n                <Box sx={{ mt: 1 }}>\n                  <Button\n                    variant=\"contained\"\n                    size=\"small\"\n                    onClick={() => setShowConfigDialog(true)}\n                    disabled={configuring}\n                    startIcon={configuring ? <CircularProgress size={16} /> : <SettingsIcon />}\n                  >\n                    {configuring ? 'Configuring...' : 'Configure LoadBalancer'}\n                  </Button>\n                </Box>\n              )}\n            </Alert>\n          )}\n\n          {status?.isConfigured && (\n            <Box>\n              <Alert severity=\"success\" sx={{ mb: 2 }}>\n                <AlertTitle>LoadBalancer Active</AlertTitle>\n                LoadBalancer controller is configured and working. Gateways will receive external IP addresses.\n              </Alert>\n\n              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>\n                {getProviderIcon()}\n                <Box>\n                  <Typography variant=\"subtitle2\">\n                    Provider: {status.provider?.toUpperCase() || 'Unknown'}\n                  </Typography>\n                  {status.version && (\n                    <Typography variant=\"body2\" color=\"text.secondary\">\n                      Version: {status.version}\n                    </Typography>\n                  )}\n                </Box>\n              </Box>\n\n              {status.ipPools && status.ipPools.length > 0 && (\n                <Box>\n                  <Typography variant=\"subtitle2\" gutterBottom>\n                    IP Address Pools:\n                  </Typography>\n                  <List dense>\n                    {status.ipPools.map((pool, index) => (\n                      <ListItem key={index} sx={{ py: 0.5, px: 0 }}>\n                        <ListItemIcon>\n                          <NetworkCheckIcon fontSize=\"small\" />\n                        </ListItemIcon>\n                        <ListItemText\n                          primary={pool.name}\n                          secondary={pool.addresses.join(', ')}\n                        />\n                      </ListItem>\n                    ))}\n                  </List>\n                </Box>\n              )}\n\n              {status.provider === 'metallb' && showConfigureButton && (\n                <Box sx={{ mt: 2 }}>\n                  <Button\n                    variant=\"outlined\"\n                    color=\"error\"\n                    size=\"small\"\n                    onClick={handleRemove}\n                    disabled={configuring}\n                    startIcon={configuring ? <CircularProgress size={16} /> : <ErrorIcon />}\n                  >\n                    {configuring ? 'Removing...' : 'Remove MetalLB'}\n                  </Button>\n                </Box>\n              )}\n            </Box>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Configuration Dialog */}\n      <Dialog open={showConfigDialog} onClose={() => setShowConfigDialog(false)} maxWidth=\"sm\" fullWidth>\n        <DialogTitle>Configure LoadBalancer (MetalLB)</DialogTitle>\n        <DialogContent>\n          <Box sx={{ mt: 1 }}>\n            <Typography variant=\"body2\" color=\"text.secondary\" gutterBottom>\n              MetalLB will provide LoadBalancer functionality for your Docker Desktop cluster.\n              This enables Gateways to receive external IP addresses.\n            </Typography>\n\n            <Divider sx={{ my: 2 }} />\n\n            <FormControlLabel\n              control={\n                <Switch\n                  checked={config.autoDetectRange}\n                  onChange={(e) => setConfig(prev => ({ ...prev, autoDetectRange: e.target.checked }))}\n                />\n              }\n              label=\"Auto-detect IP range\"\n            />\n\n            {!config.autoDetectRange && (\n              <TextField\n                fullWidth\n                label=\"IP Address Range\"\n                value={config.ipRange}\n                onChange={(e) => setConfig(prev => ({ ...prev, ipRange: e.target.value }))}\n                placeholder=\"172.18.200.1-172.18.200.100\"\n                helperText=\"Specify the IP range for LoadBalancer services (e.g., 172.18.200.1-172.18.200.100)\"\n                sx={{ mt: 2 }}\n              />\n            )}\n\n            <Alert severity=\"info\" sx={{ mt: 2 }}>\n              <Typography variant=\"body2\">\n                MetalLB will be installed in the <code>metallb-system</code> namespace.\n                {config.autoDetectRange ? ' The IP range will be automatically detected based on your Docker network configuration.' : ''}\n              </Typography>\n            </Alert>\n\n            {configuring && (\n              <Box sx={{ mt: 2 }}>\n                <Typography variant=\"body2\" gutterBottom>\n                  Installing and configuring MetalLB...\n                </Typography>\n                <LinearProgress />\n              </Box>\n            )}\n          </Box>\n        </DialogContent>\n        <DialogActions>\n          <Button \n            onClick={() => setShowConfigDialog(false)}\n            disabled={configuring}\n          >\n            Cancel\n          </Button>\n          <Button\n            onClick={handleConfigure}\n            variant=\"contained\"\n            disabled={configuring || (!config.autoDetectRange && !config.ipRange.trim())}\n            startIcon={configuring ? <CircularProgress size={16} /> : <SettingsIcon />}\n          >\n            {configuring ? 'Installing...' : 'Install & Configure'}\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </Box>\n  );\n};","/Users/saptak/code/envddext/ui/src/components/PodStatusIndicator.tsx",[],[],"/Users/saptak/code/envddext/ui/src/components/DeploymentTroubleshooter.tsx",["160","161"],[],"import React from 'react';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails,\n  Link,\n  List,\n  ListItem,\n  ListItemIcon,\n  ListItemText\n} from '@mui/material';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport WarningIcon from '@mui/icons-material/Warning';\nimport ErrorIcon from '@mui/icons-material/Error';\nimport HelpIcon from '@mui/icons-material/Help';\nimport BugReportIcon from '@mui/icons-material/BugReport';\nimport BuildIcon from '@mui/icons-material/Build';\n\ninterface DeploymentTroubleshooterProps {\n  deploymentStatus: any;\n  podDetails: any[];\n}\n\nexport const DeploymentTroubleshooter: React.FC<DeploymentTroubleshooterProps> = ({\n  deploymentStatus,\n  podDetails\n}) => {\n  // Identify common issues\n  const issues = identifyIssues(deploymentStatus, podDetails);\n  \n  if (issues.length === 0) {\n    return null;\n  }\n  \n  return (\n    <Box>\n      <Typography variant=\"subtitle1\" gutterBottom>\n        Troubleshooting\n      </Typography>\n      \n      {issues.map((issue, index) => (\n        <Accordion key={index} sx={{ mb: 1 }}>\n          <AccordionSummary expandIcon={<ExpandMoreIcon />}>\n            <Box sx={{ display: 'flex', alignItems: 'center' }}>\n              {issue.severity === 'error' ? (\n                <ErrorIcon color=\"error\" sx={{ mr: 1 }} />\n              ) : (\n                <WarningIcon color=\"warning\" sx={{ mr: 1 }} />\n              )}\n              <Typography variant=\"body2\" fontWeight=\"medium\">\n                {issue.title}\n              </Typography>\n            </Box>\n          </AccordionSummary>\n          <AccordionDetails>\n            <Typography variant=\"body2\" paragraph>\n              {issue.description}\n            </Typography>\n            \n            {issue.steps && (\n              <>\n                <Typography variant=\"body2\" fontWeight=\"medium\" gutterBottom>\n                  Suggested steps:\n                </Typography>\n                <List dense disablePadding>\n                  {issue.steps.map((step, stepIndex) => (\n                    <ListItem key={stepIndex} disablePadding sx={{ py: 0.5 }}>\n                      <ListItemIcon sx={{ minWidth: 30 }}>\n                        <BuildIcon fontSize=\"small\" />\n                      </ListItemIcon>\n                      <ListItemText\n                        primary={step}\n                        primaryTypographyProps={{ variant: 'body2' }}\n                      />\n                    </ListItem>\n                  ))}\n                </List>\n              </>\n            )}\n            \n            {issue.docs && (\n              <Box sx={{ mt: 1 }}>\n                <Typography variant=\"body2\" fontWeight=\"medium\" gutterBottom>\n                  Documentation:\n                </Typography>\n                <List dense disablePadding>\n                  {issue.docs.map((doc, docIndex) => (\n                    <ListItem key={docIndex} disablePadding sx={{ py: 0.5 }}>\n                      <ListItemIcon sx={{ minWidth: 30 }}>\n                        <HelpIcon fontSize=\"small\" />\n                      </ListItemIcon>\n                      <ListItemText\n                        primary={\n                          <Link href={doc.url} target=\"_blank\" rel=\"noopener\">\n                            {doc.title}\n                          </Link>\n                        }\n                        primaryTypographyProps={{ variant: 'body2' }}\n                      />\n                    </ListItem>\n                  ))}\n                </List>\n              </Box>\n            )}\n          </AccordionDetails>\n        </Accordion>\n      ))}\n    </Box>\n  );\n};\n\ninterface Issue {\n  severity: 'warning' | 'error';\n  title: string;\n  description: string;\n  steps?: string[];\n  docs?: { title: string; url: string }[];\n}\n\nconst identifyIssues = (deploymentStatus: any, podDetails: any[]): Issue[] => {\n  const issues: Issue[] = [];\n  \n  // Check if deployment exists\n  if (deploymentStatus.status === 'not_found') {\n    issues.push({\n      severity: 'error',\n      title: 'Deployment not found',\n      description: 'The deployment could not be found in the specified namespace.',\n      steps: [\n        'Verify that you have applied the template correctly',\n        'Check if the namespace exists',\n        'Check if the deployment was deleted'\n      ],\n      docs: [\n        {\n          title: 'Kubernetes Deployments',\n          url: 'https://kubernetes.io/docs/concepts/workloads/controllers/deployment/'\n        }\n      ]\n    });\n    return issues;\n  }\n  \n  // Check for insufficient replicas\n  if (deploymentStatus.readyReplicas < deploymentStatus.desiredReplicas) {\n    issues.push({\n      severity: 'warning',\n      title: 'Insufficient ready replicas',\n      description: `Only ${deploymentStatus.readyReplicas} of ${deploymentStatus.desiredReplicas} desired replicas are ready.`,\n      steps: [\n        'Check pod status for more details',\n        'Verify that resources (CPU/memory) are available in the cluster',\n        'Check for pod scheduling issues'\n      ]\n    });\n  }\n  \n  // Check for pod issues\n  for (const pod of podDetails) {\n    const podPhase = pod.status?.phase;\n    const containerStatuses = pod.status?.containerStatuses || [];\n    \n    // Check for pending pods\n    if (podPhase === 'Pending') {\n      issues.push({\n        severity: 'warning',\n        title: `Pod ${pod.metadata.name} is pending`,\n        description: 'The pod is in Pending state and not yet running.',\n        steps: [\n          'Check if there are sufficient resources in the cluster',\n          'Verify that the pod can be scheduled (no taints preventing scheduling)',\n          'Check events for more details'\n        ]\n      });\n    }\n    \n    // Check for failed pods\n    if (podPhase === 'Failed') {\n      issues.push({\n        severity: 'error',\n        title: `Pod ${pod.metadata.name} has failed`,\n        description: 'The pod is in Failed state.',\n        steps: [\n          'Check the pod logs for error messages',\n          'Verify that the container image exists and is accessible',\n          'Check if the container is crashing on startup'\n        ]\n      });\n    }\n    \n    // Check for container issues\n    for (const cs of containerStatuses) {\n      if (!cs.ready) {\n        if (cs.state?.waiting) {\n          const reason = cs.state.waiting.reason;\n          const message = cs.state.waiting.message;\n          \n          issues.push({\n            severity: reason === 'ContainerCreating' ? 'warning' : 'error',\n            title: `Container ${cs.name} is waiting: ${reason}`,\n            description: message || `The container is waiting due to: ${reason}`,\n            steps: getStepsForContainerIssue(reason)\n          });\n        } else if (cs.state?.terminated) {\n          const reason = cs.state.terminated.reason;\n          const exitCode = cs.state.terminated.exitCode;\n          \n          issues.push({\n            severity: 'error',\n            title: `Container ${cs.name} terminated: ${reason} (Exit code: ${exitCode})`,\n            description: `The container has terminated with exit code ${exitCode}.`,\n            steps: [\n              'Check the container logs for error messages',\n              'Verify that the application inside the container is configured correctly',\n              `Research the specific exit code ${exitCode} for your application`\n            ]\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for events that indicate issues\n  const errorEvents = podDetails.flatMap(pod => \n    (pod.events || []).filter((event: any) => event.type === 'Warning')\n  );\n  \n  for (const event of errorEvents) {\n    issues.push({\n      severity: 'warning',\n      title: `Event: ${event.reason}`,\n      description: event.message,\n      steps: getStepsForEventIssue(event.reason)\n    });\n  }\n  \n  return issues;\n};\n\nconst getStepsForContainerIssue = (reason: string): string[] => {\n  switch (reason) {\n    case 'ImagePullBackOff':\n    case 'ErrImagePull':\n      return [\n        'Verify that the image name is correct',\n        'Check if the image exists in the registry',\n        'Ensure that the cluster has access to the image registry',\n        'If using a private registry, check that pull secrets are configured'\n      ];\n    case 'CrashLoopBackOff':\n      return [\n        'Check the container logs for error messages',\n        'Verify that the application inside the container is configured correctly',\n        'Ensure the container has the resources it needs',\n        'Check if the container is exiting immediately after starting'\n      ];\n    case 'ContainerCreating':\n      return [\n        'Wait for the container to finish creating',\n        'Check if there are resource constraints',\n        'Verify that volumes can be mounted correctly'\n      ];\n    default:\n      return [\n        'Check the pod events for more details',\n        'Inspect the container logs',\n        'Verify the deployment configuration'\n      ];\n  }\n};\n\nconst getStepsForEventIssue = (reason: string): string[] => {\n  switch (reason) {\n    case 'FailedScheduling':\n      return [\n        'Check if there are sufficient resources in the cluster',\n        'Verify that there are no node taints preventing scheduling',\n        'Ensure that node selectors or affinity rules can be satisfied'\n      ];\n    case 'FailedMount':\n      return [\n        'Verify that the referenced volumes exist',\n        'Check permissions on the volumes',\n        'Ensure that PersistentVolumeClaims are bound'\n      ];\n    default:\n      return [\n        'Check the pod events for more details',\n        'Inspect the container logs',\n        'Verify the deployment configuration'\n      ];\n  }\n};\n","/Users/saptak/code/envddext/ui/src/components/GatewayStatusMonitor.tsx",["162"],[],"import React, { useState, useEffect } from 'react';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Chip,\n  IconButton,\n  Tooltip,\n  CircularProgress,\n  Collapse,\n  List,\n  ListItem,\n  ListItemIcon,\n  ListItemText,\n  Divider,\n  Alert,\n  Button\n} from '@mui/material';\nimport CheckCircleIcon from '@mui/icons-material/CheckCircle';\nimport ErrorIcon from '@mui/icons-material/Error';\nimport WarningIcon from '@mui/icons-material/Warning';\nimport HourglassEmptyIcon from '@mui/icons-material/HourglassEmpty';\nimport RefreshIcon from '@mui/icons-material/Refresh';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport InfoIcon from '@mui/icons-material/Info';\nimport NetworkCheckIcon from '@mui/icons-material/NetworkCheck';\nimport { createDockerDesktopClient } from \"@docker/extension-api-client\";\nimport { GatewayStatusInfo } from '../types/gateway';\nimport { getGatewayStatus, deleteGateway } from '../helper/kubernetes';\n\nconst ddClient = createDockerDesktopClient();\n\ninterface GatewayStatusMonitorProps {\n  gatewayName: string;\n  namespace: string;\n  onDelete?: () => void;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\nexport const GatewayStatusMonitor: React.FC<GatewayStatusMonitorProps> = ({\n  gatewayName,\n  namespace,\n  onDelete,\n  autoRefresh = true,\n  refreshInterval = 5000\n}) => {\n  const [gatewayStatus, setGatewayStatus] = useState<GatewayStatusInfo | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [expanded, setExpanded] = useState(false);\n  const [lastRefreshed, setLastRefreshed] = useState<Date>(new Date());\n  const [deleting, setDeleting] = useState(false);\n\n  useEffect(() => {\n    fetchGatewayStatus();\n    \n    if (autoRefresh) {\n      const interval = setInterval(fetchGatewayStatus, refreshInterval);\n      return () => clearInterval(interval);\n    }\n  }, [gatewayName, namespace, autoRefresh, refreshInterval]);\n\n  const fetchGatewayStatus = async () => {\n    try {\n      setError(null);\n      const status = await getGatewayStatus(ddClient, namespace, gatewayName);\n      setGatewayStatus(status);\n      setLastRefreshed(new Date());\n    } catch (err: any) {\n      setError(typeof err === 'string' ? err : 'Failed to fetch Gateway status');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleRefresh = () => {\n    setLoading(true);\n    fetchGatewayStatus();\n  };\n\n  const handleDelete = async () => {\n    if (!window.confirm(`Are you sure you want to delete Gateway \"${gatewayName}\"?`)) {\n      return;\n    }\n\n    setDeleting(true);\n    try {\n      const result = await deleteGateway(ddClient, namespace, gatewayName);\n      if (result.success) {\n        onDelete?.();\n      } else {\n        setError(result.error || 'Failed to delete Gateway');\n      }\n    } catch (err: any) {\n      setError(typeof err === 'string' ? err : 'Failed to delete Gateway');\n    } finally {\n      setDeleting(false);\n    }\n  };\n\n  const getStatusIcon = (status: string) => {\n    switch (status) {\n      case 'ready':\n        return <CheckCircleIcon color=\"success\" />;\n      case 'failed':\n        return <ErrorIcon color=\"error\" />;\n      case 'pending':\n        return <HourglassEmptyIcon color=\"warning\" />;\n      default:\n        return <WarningIcon color=\"warning\" />;\n    }\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'ready':\n        return 'success';\n      case 'failed':\n        return 'error';\n      case 'pending':\n        return 'warning';\n      default:\n        return 'default';\n    }\n  };\n\n  const getListenerStatusIcon = (status: string) => {\n    switch (status) {\n      case 'ready':\n        return <CheckCircleIcon color=\"success\" fontSize=\"small\" />;\n      case 'failed':\n        return <ErrorIcon color=\"error\" fontSize=\"small\" />;\n      default:\n        return <HourglassEmptyIcon color=\"warning\" fontSize=\"small\" />;\n    }\n  };\n\n  if (error) {\n    return (\n      <Paper variant=\"outlined\" sx={{ mb: 2, p: 2 }}>\n        <Alert severity=\"error\">\n          <Typography variant=\"subtitle2\">Error loading Gateway status</Typography>\n          <Typography variant=\"body2\">{error}</Typography>\n          <Button size=\"small\" onClick={handleRefresh} sx={{ mt: 1 }}>\n            Retry\n          </Button>\n        </Alert>\n      </Paper>\n    );\n  }\n\n  if (!gatewayStatus) {\n    return (\n      <Paper variant=\"outlined\" sx={{ mb: 2, p: 2 }}>\n        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>\n          <CircularProgress size={20} sx={{ mr: 1 }} />\n          <Typography variant=\"body2\">Loading Gateway status...</Typography>\n        </Box>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper variant=\"outlined\" sx={{ mb: 2 }}>\n      <Box sx={{ p: 2 }}>\n        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n          <Box sx={{ display: 'flex', alignItems: 'center' }}>\n            {getStatusIcon(gatewayStatus.status)}\n            <Typography variant=\"h6\" sx={{ ml: 1 }}>\n              {gatewayName}\n            </Typography>\n            <Chip \n              label={gatewayStatus.status.toUpperCase()} \n              size=\"small\" \n              color={getStatusColor(gatewayStatus.status) as any} \n              variant=\"outlined\" \n              sx={{ ml: 2 }}\n            />\n            {gatewayStatus.age && (\n              <Typography variant=\"caption\" color=\"text.secondary\" sx={{ ml: 2 }}>\n                {gatewayStatus.age}\n              </Typography>\n            )}\n          </Box>\n          <Box>\n            <Tooltip title={`Last refreshed: ${lastRefreshed.toLocaleTimeString()}`}>\n              <IconButton size=\"small\" onClick={handleRefresh} disabled={loading}>\n                {loading ? <CircularProgress size={18} /> : <RefreshIcon />}\n              </IconButton>\n            </Tooltip>\n            {onDelete && (\n              <Tooltip title=\"Delete Gateway\">\n                <IconButton \n                  size=\"small\" \n                  onClick={handleDelete} \n                  disabled={deleting}\n                  color=\"error\"\n                >\n                  {deleting ? <CircularProgress size={18} /> : <DeleteIcon />}\n                </IconButton>\n              </Tooltip>\n            )}\n            <IconButton \n              size=\"small\" \n              onClick={() => setExpanded(!expanded)}\n              sx={{ \n                transform: expanded ? 'rotate(180deg)' : 'rotate(0deg)', \n                transition: 'transform 0.2s' \n              }}\n            >\n              <ExpandMoreIcon />\n            </IconButton>\n          </Box>\n        </Box>\n\n        <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mt: 1 }}>\n          Namespace: {namespace}\n        </Typography>\n\n        {gatewayStatus.message && (\n          <Typography variant=\"body2\" sx={{ mt: 1 }}>\n            {gatewayStatus.message}\n          </Typography>\n        )}\n\n        {/* Gateway Addresses */}\n        {gatewayStatus.addresses && gatewayStatus.addresses.length > 0 && (\n          <Box sx={{ mt: 2 }}>\n            <Typography variant=\"subtitle2\" gutterBottom>\n              Gateway Addresses:\n            </Typography>\n            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>\n              {gatewayStatus.addresses.map((address, index) => (\n                <Chip\n                  key={index}\n                  label={address}\n                  size=\"small\"\n                  icon={<NetworkCheckIcon />}\n                  variant=\"outlined\"\n                />\n              ))}\n            </Box>\n          </Box>\n        )}\n\n        <Collapse in={expanded}>\n          <Box sx={{ mt: 2 }}>\n            <Divider sx={{ mb: 2 }} />\n\n            {/* Listeners Status */}\n            {gatewayStatus.listeners && gatewayStatus.listeners.length > 0 && (\n              <Box sx={{ mb: 3 }}>\n                <Typography variant=\"subtitle2\" gutterBottom>\n                  Listeners Status:\n                </Typography>\n                <List dense>\n                  {gatewayStatus.listeners.map((listener, index) => (\n                    <ListItem key={index} sx={{ pl: 0 }}>\n                      <ListItemIcon sx={{ minWidth: 32 }}>\n                        {getListenerStatusIcon(listener.status)}\n                      </ListItemIcon>\n                      <ListItemText\n                        primary={\n                          <Box sx={{ display: 'flex', alignItems: 'center' }}>\n                            <Typography variant=\"body2\" fontWeight=\"medium\">\n                              {listener.name}\n                            </Typography>\n                            <Chip\n                              label={`${listener.attachedRoutes} routes`}\n                              size=\"small\"\n                              variant=\"outlined\"\n                              sx={{ ml: 1 }}\n                            />\n                          </Box>\n                        }\n                        secondary={listener.message}\n                      />\n                    </ListItem>\n                  ))}\n                </List>\n              </Box>\n            )}\n\n            {/* Conditions */}\n            {gatewayStatus.conditions && gatewayStatus.conditions.length > 0 && (\n              <Box>\n                <Typography variant=\"subtitle2\" gutterBottom>\n                  Conditions:\n                </Typography>\n                <List dense>\n                  {gatewayStatus.conditions.map((condition, index) => (\n                    <ListItem key={index} sx={{ pl: 0 }}>\n                      <ListItemIcon sx={{ minWidth: 32 }}>\n                        {condition.status === 'True' ? (\n                          <CheckCircleIcon color=\"success\" fontSize=\"small\" />\n                        ) : condition.status === 'False' ? (\n                          <ErrorIcon color=\"error\" fontSize=\"small\" />\n                        ) : (\n                          <InfoIcon color=\"info\" fontSize=\"small\" />\n                        )}\n                      </ListItemIcon>\n                      <ListItemText\n                        primary={\n                          <Box sx={{ display: 'flex', alignItems: 'center' }}>\n                            <Typography variant=\"body2\" fontWeight=\"medium\">\n                              {condition.type}\n                            </Typography>\n                            <Chip\n                              label={condition.status}\n                              size=\"small\"\n                              color={\n                                condition.status === 'True' ? 'success' :\n                                condition.status === 'False' ? 'error' : 'default'\n                              }\n                              variant=\"outlined\"\n                              sx={{ ml: 1 }}\n                            />\n                          </Box>\n                        }\n                        secondary={\n                          <Box>\n                            <Typography variant=\"caption\" display=\"block\">\n                              {condition.reason}: {condition.message}\n                            </Typography>\n                            <Typography variant=\"caption\" color=\"text.secondary\">\n                              Last transition: {new Date(condition.lastTransitionTime).toLocaleString()}\n                            </Typography>\n                          </Box>\n                        }\n                      />\n                    </ListItem>\n                  ))}\n                </List>\n              </Box>\n            )}\n          </Box>\n        </Collapse>\n      </Box>\n    </Paper>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/components/HTTPRequestHistory.tsx",["163"],[],"import React, { useState } from 'react';\nimport {\n  Box,\n  Typography,\n  Paper,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemSecondaryAction,\n  IconButton,\n  Chip,\n  Button,\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  Tooltip,\n  Divider,\n  Alert\n} from '@mui/material';\nimport ReplayIcon from '@mui/icons-material/Replay';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport ClearAllIcon from '@mui/icons-material/ClearAll';\nimport VisibilityIcon from '@mui/icons-material/Visibility';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport { TestResult } from '../types/httpClient';\nimport { HTTPResponseDisplay } from './HTTPResponseDisplay';\n\ninterface HTTPRequestHistoryProps {\n  history: TestResult[];\n  onReplay: (result: TestResult) => void;\n  onClear: () => void;\n}\n\nexport const HTTPRequestHistory: React.FC<HTTPRequestHistoryProps> = ({\n  history,\n  onReplay,\n  onClear\n}) => {\n  const [selectedResult, setSelectedResult] = useState<TestResult | null>(null);\n  const [detailsOpen, setDetailsOpen] = useState(false);\n\n  const getStatusColor = (status?: number): 'success' | 'warning' | 'error' | 'default' => {\n    if (!status) return 'default';\n    if (status >= 200 && status < 300) return 'success';\n    if (status >= 300 && status < 400) return 'warning';\n    if (status >= 400) return 'error';\n    return 'default';\n  };\n\n  const formatTime = (date: Date): string => {\n    return date.toLocaleTimeString();\n  };\n\n  const formatDuration = (ms: number): string => {\n    if (ms < 1000) return `${ms}ms`;\n    return `${(ms / 1000).toFixed(2)}s`;\n  };\n\n  const handleViewDetails = (result: TestResult) => {\n    setSelectedResult(result);\n    setDetailsOpen(true);\n  };\n\n  const handleCopyCurl = async (curlCommand: string) => {\n    try {\n      await navigator.clipboard.writeText(curlCommand);\n      // Could add a toast notification here\n    } catch (error) {\n      console.error('Failed to copy to clipboard:', error);\n    }\n  };\n\n  const truncateUrl = (url: string, maxLength: number = 50): string => {\n    if (url.length <= maxLength) return url;\n    return url.substring(0, maxLength) + '...';\n  };\n\n  if (history.length === 0) {\n    return (\n      <Alert severity=\"info\" sx={{ backgroundColor: 'background.default' }}>\n        No requests in history yet. Send a request to see it appear here.\n      </Alert>\n    );\n  }\n\n  return (\n    <Box>\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>\n        <Typography variant=\"h6\">\n          Request History ({history.length})\n        </Typography>\n        <Button\n          startIcon={<ClearAllIcon />}\n          onClick={onClear}\n          variant=\"outlined\"\n          size=\"small\"\n          disabled={history.length === 0}\n        >\n          Clear All\n        </Button>\n      </Box>\n\n      <Paper \n        elevation={1} \n        sx={{ \n          backgroundColor: 'background.paper',\n          border: '1px solid',\n          borderColor: 'divider',\n          maxHeight: 500,\n          overflow: 'auto'\n        }}\n      >\n        <List sx={{ p: 0 }}>\n          {history.map((result, index) => (\n            <React.Fragment key={result.id}>\n              <ListItem\n                sx={{\n                  py: 2,\n                  '&:hover': {\n                    backgroundColor: 'action.hover'\n                  }\n                }}\n              >\n                <ListItemText\n                  primary={\n                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>\n                      <Chip\n                        label={result.request.method}\n                        size=\"small\"\n                        color=\"primary\"\n                        variant=\"outlined\"\n                      />\n                      {result.response && (\n                        <Chip\n                          label={result.response.status}\n                          size=\"small\"\n                          color={getStatusColor(result.response.status)}\n                          variant=\"filled\"\n                        />\n                      )}\n                      {result.error && (\n                        <Chip\n                          label=\"ERROR\"\n                          size=\"small\"\n                          color=\"error\"\n                          variant=\"filled\"\n                        />\n                      )}\n                      <Typography variant=\"body2\" color=\"text.secondary\">\n                        {formatTime(result.timestamp)}\n                      </Typography>\n                    </Box>\n                  }\n                  secondary={\n                    <Box>\n                      <Typography \n                        variant=\"body2\" \n                        sx={{ \n                          fontFamily: 'monospace',\n                          color: 'text.primary',\n                          mb: 0.5\n                        }}\n                      >\n                        {truncateUrl(result.request.url)}\n                      </Typography>\n                      {result.response && (\n                        <Typography variant=\"caption\" color=\"text.secondary\">\n                          {formatDuration(result.response.responseTime)}  \n                          {result.response.size} bytes\n                        </Typography>\n                      )}\n                      {result.error && (\n                        <Typography variant=\"caption\" color=\"error.main\">\n                          {result.error}\n                        </Typography>\n                      )}\n                    </Box>\n                  }\n                />\n                <ListItemSecondaryAction>\n                  <Box sx={{ display: 'flex', gap: 0.5 }}>\n                    <Tooltip title=\"Replay request\">\n                      <IconButton\n                        size=\"small\"\n                        onClick={() => onReplay(result)}\n                      >\n                        <ReplayIcon />\n                      </IconButton>\n                    </Tooltip>\n                    \n                    {result.response && (\n                      <Tooltip title=\"View details\">\n                        <IconButton\n                          size=\"small\"\n                          onClick={() => handleViewDetails(result)}\n                        >\n                          <VisibilityIcon />\n                        </IconButton>\n                      </Tooltip>\n                    )}\n                    \n                    <Tooltip title=\"Copy as cURL\">\n                      <IconButton\n                        size=\"small\"\n                        onClick={() => handleCopyCurl(result.curlCommand)}\n                      >\n                        <ContentCopyIcon />\n                      </IconButton>\n                    </Tooltip>\n                  </Box>\n                </ListItemSecondaryAction>\n              </ListItem>\n              {index < history.length - 1 && <Divider />}\n            </React.Fragment>\n          ))}\n        </List>\n      </Paper>\n\n      {/* Details Dialog */}\n      <Dialog\n        open={detailsOpen}\n        onClose={() => setDetailsOpen(false)}\n        maxWidth=\"md\"\n        fullWidth\n        PaperProps={{\n          sx: {\n            backgroundColor: 'background.paper',\n            border: '1px solid',\n            borderColor: 'divider'\n          }\n        }}\n      >\n        <DialogTitle sx={{ backgroundColor: 'background.default' }}>\n          Request Details\n        </DialogTitle>\n        <DialogContent sx={{ p: 0 }}>\n          {selectedResult && (\n            <Box sx={{ p: 3 }}>\n              {/* Request Info */}\n              <Typography variant=\"h6\" gutterBottom>\n                Request\n              </Typography>\n              <Paper \n                elevation={1} \n                sx={{ \n                  p: 2, \n                  mb: 3, \n                  backgroundColor: 'background.default',\n                  border: '1px solid',\n                  borderColor: 'divider'\n                }}\n              >\n                <Typography variant=\"body2\" sx={{ fontFamily: 'monospace' }}>\n                  <strong>{selectedResult.request.method}</strong> {selectedResult.request.url}\n                </Typography>\n                <Typography variant=\"caption\" color=\"text.secondary\">\n                  {selectedResult.timestamp.toLocaleString()}\n                </Typography>\n              </Paper>\n\n              {/* Response */}\n              {selectedResult.response ? (\n                <Box>\n                  <Typography variant=\"h6\" gutterBottom>\n                    Response\n                  </Typography>\n                  <HTTPResponseDisplay response={selectedResult.response} />\n                </Box>\n              ) : selectedResult.error ? (\n                <Box>\n                  <Typography variant=\"h6\" gutterBottom>\n                    Error\n                  </Typography>\n                  <Alert severity=\"error\">\n                    {selectedResult.error}\n                  </Alert>\n                </Box>\n              ) : null}\n            </Box>\n          )}\n        </DialogContent>\n        <DialogActions sx={{ backgroundColor: 'background.default' }}>\n          <Button onClick={() => setDetailsOpen(false)}>\n            Close\n          </Button>\n          {selectedResult && (\n            <Button\n              onClick={() => {\n                onReplay(selectedResult);\n                setDetailsOpen(false);\n              }}\n              variant=\"contained\"\n              startIcon={<ReplayIcon />}\n            >\n              Replay\n            </Button>\n          )}\n        </DialogActions>\n      </Dialog>\n    </Box>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/components/CurlCommandDisplay.tsx",["164"],[],"import React, { useState } from 'react';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Button,\n  IconButton,\n  Tooltip,\n  FormControlLabel,\n  Switch,\n  Grid,\n  Alert,\n  Divider\n} from '@mui/material';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport LaunchIcon from '@mui/icons-material/Launch';\nimport SettingsIcon from '@mui/icons-material/Settings';\nimport { HTTPRequest, CurlCommandOptions } from '../types/httpClient';\nimport { generateFormattedCurlCommand, getCurlExamples } from '../utils/curlGenerator';\n\ninterface CurlCommandDisplayProps {\n  curlCommand: string;\n  request: HTTPRequest;\n}\n\nexport const CurlCommandDisplay: React.FC<CurlCommandDisplayProps> = ({\n  curlCommand,\n  request\n}) => {\n  const [copied, setCopied] = useState(false);\n  const [showOptions, setShowOptions] = useState(false);\n  const [options, setOptions] = useState<CurlCommandOptions>({\n    includeHeaders: true,\n    includeVerbose: false,\n    includeTiming: false,\n    includeInsecure: false\n  });\n\n  const handleCopy = async (command: string) => {\n    try {\n      await navigator.clipboard.writeText(command);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (error) {\n      console.error('Failed to copy to clipboard:', error);\n    }\n  };\n\n  const handleOptionChange = (option: keyof CurlCommandOptions) => {\n    setOptions(prev => ({\n      ...prev,\n      [option]: !prev[option]\n    }));\n  };\n\n  const customCurlCommand = generateFormattedCurlCommand(request, options);\n  const examples = getCurlExamples();\n\n  return (\n    <Box>\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>\n        <Typography variant=\"h6\">\n          cURL Command\n        </Typography>\n        <Box>\n          <Tooltip title=\"Customize options\">\n            <IconButton\n              size=\"small\"\n              onClick={() => setShowOptions(!showOptions)}\n              color={showOptions ? 'primary' : 'default'}\n            >\n              <SettingsIcon />\n            </IconButton>\n          </Tooltip>\n        </Box>\n      </Box>\n\n      {/* Options Panel */}\n      {showOptions && (\n        <Paper \n          elevation={1} \n          sx={{ \n            p: 2, \n            mb: 2, \n            backgroundColor: 'background.default',\n            border: '1px solid',\n            borderColor: 'divider'\n          }}\n        >\n          <Typography variant=\"subtitle2\" gutterBottom>\n            Command Options\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={6} sm={3}>\n              <FormControlLabel\n                control={\n                  <Switch\n                    checked={options.includeHeaders}\n                    onChange={() => handleOptionChange('includeHeaders')}\n                    size=\"small\"\n                  />\n                }\n                label=\"Include Headers\"\n              />\n            </Grid>\n            <Grid item xs={6} sm={3}>\n              <FormControlLabel\n                control={\n                  <Switch\n                    checked={options.includeVerbose}\n                    onChange={() => handleOptionChange('includeVerbose')}\n                    size=\"small\"\n                  />\n                }\n                label=\"Verbose Output\"\n              />\n            </Grid>\n            <Grid item xs={6} sm={3}>\n              <FormControlLabel\n                control={\n                  <Switch\n                    checked={options.includeTiming}\n                    onChange={() => handleOptionChange('includeTiming')}\n                    size=\"small\"\n                  />\n                }\n                label=\"Show Timing\"\n              />\n            </Grid>\n            <Grid item xs={6} sm={3}>\n              <FormControlLabel\n                control={\n                  <Switch\n                    checked={options.includeInsecure}\n                    onChange={() => handleOptionChange('includeInsecure')}\n                    size=\"small\"\n                  />\n                }\n                label=\"Allow Insecure\"\n              />\n            </Grid>\n          </Grid>\n        </Paper>\n      )}\n\n      {/* Generated Command */}\n      <Paper \n        elevation={1} \n        sx={{ \n          backgroundColor: 'background.paper',\n          border: '1px solid',\n          borderColor: 'divider',\n          mb: 2\n        }}\n      >\n        <Box \n          sx={{ \n            p: 2, \n            backgroundColor: 'background.default',\n            borderBottom: '1px solid',\n            borderColor: 'divider',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'space-between'\n          }}\n        >\n          <Typography variant=\"subtitle2\">\n            Generated Command\n          </Typography>\n          <Box sx={{ display: 'flex', gap: 1 }}>\n            <Button\n              size=\"small\"\n              startIcon={<ContentCopyIcon />}\n              onClick={() => handleCopy(showOptions ? customCurlCommand : curlCommand)}\n              variant=\"outlined\"\n            >\n              {copied ? 'Copied!' : 'Copy'}\n            </Button>\n          </Box>\n        </Box>\n        \n        <Box sx={{ p: 2 }}>\n          <Box\n            component=\"pre\"\n            sx={{\n              backgroundColor: 'grey.900',\n              color: 'grey.100',\n              p: 2,\n              borderRadius: 1,\n              overflow: 'auto',\n              fontSize: '0.875rem',\n              fontFamily: 'monospace',\n              margin: 0,\n              whiteSpace: 'pre-wrap',\n              wordBreak: 'break-word'\n            }}\n          >\n            {showOptions ? customCurlCommand : curlCommand}\n          </Box>\n        </Box>\n      </Paper>\n\n      {/* Usage Instructions */}\n      <Alert severity=\"info\" sx={{ mb: 2, backgroundColor: 'background.default' }}>\n        <Typography variant=\"body2\">\n          Copy this command and run it in your terminal to execute the same request outside of this extension.\n        </Typography>\n      </Alert>\n\n      {/* Examples */}\n      <Paper \n        elevation={1} \n        sx={{ \n          backgroundColor: 'background.paper',\n          border: '1px solid',\n          borderColor: 'divider'\n        }}\n      >\n        <Box \n          sx={{ \n            p: 2, \n            backgroundColor: 'background.default',\n            borderBottom: '1px solid',\n            borderColor: 'divider'\n          }}\n        >\n          <Typography variant=\"subtitle2\">\n            Common cURL Examples\n          </Typography>\n        </Box>\n        \n        <Box sx={{ p: 2 }}>\n          {Object.entries(examples).map(([key, example], index) => (\n            <Box key={key}>\n              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>\n                <Typography variant=\"body2\" fontWeight=\"medium\">\n                  {example.title}\n                </Typography>\n                <Tooltip title=\"Copy example\">\n                  <IconButton\n                    size=\"small\"\n                    onClick={() => handleCopy(example.command)}\n                  >\n                    <ContentCopyIcon fontSize=\"small\" />\n                  </IconButton>\n                </Tooltip>\n              </Box>\n              <Box\n                component=\"pre\"\n                sx={{\n                  backgroundColor: 'grey.900',\n                  color: 'grey.100',\n                  p: 1.5,\n                  borderRadius: 1,\n                  overflow: 'auto',\n                  fontSize: '0.75rem',\n                  fontFamily: 'monospace',\n                  margin: 0,\n                  mb: index < Object.keys(examples).length - 1 ? 2 : 0,\n                  whiteSpace: 'pre-wrap',\n                  wordBreak: 'break-word'\n                }}\n              >\n                {example.command}\n              </Box>\n              {index < Object.keys(examples).length - 1 && (\n                <Divider sx={{ my: 2 }} />\n              )}\n            </Box>\n          ))}\n        </Box>\n      </Paper>\n\n      {/* Tips */}\n      <Box sx={{ mt: 2, p: 2, backgroundColor: 'background.default', borderRadius: 1 }}>\n        <Typography variant=\"caption\" color=\"text.secondary\">\n          <strong>Tips:</strong> Use -v for verbose output, -i to include response headers, \n          -w for timing information, and -k to allow insecure HTTPS connections.\n        </Typography>\n      </Box>\n    </Box>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/types/httpClient.ts",[],[],"/Users/saptak/code/envddext/ui/src/utils/curlGenerator.ts",[],[],"/Users/saptak/code/envddext/ui/src/components/HTTPResponseDisplay.tsx",["165"],[],"import React, { useState } from 'react';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Chip,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails,\n  IconButton,\n  Tooltip,\n  Grid,\n  Divider,\n  Alert\n} from '@mui/material';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport CheckCircleIcon from '@mui/icons-material/CheckCircle';\nimport ErrorIcon from '@mui/icons-material/Error';\nimport WarningIcon from '@mui/icons-material/Warning';\nimport InfoIcon from '@mui/icons-material/Info';\nimport { HTTPResponse } from '../types/httpClient';\nimport { HTTPClientService } from '../services/httpClientService';\n\ninterface HTTPResponseDisplayProps {\n  response: HTTPResponse;\n}\n\nexport const HTTPResponseDisplay: React.FC<HTTPResponseDisplayProps> = ({ response }) => {\n  const [copiedSection, setCopiedSection] = useState<string | null>(null);\n  const httpService = new HTTPClientService(null as any); // Only using for formatting\n  const formatting = httpService.formatResponse(response);\n\n  const getStatusColor = (status: number): 'success' | 'warning' | 'error' | 'info' => {\n    if (status >= 200 && status < 300) return 'success';\n    if (status >= 300 && status < 400) return 'warning';\n    if (status >= 400) return 'error';\n    return 'info';\n  };\n\n  const getStatusIcon = (status: number) => {\n    if (status >= 200 && status < 300) return <CheckCircleIcon />;\n    if (status >= 300 && status < 400) return <WarningIcon />;\n    if (status >= 400) return <ErrorIcon />;\n    return <InfoIcon />;\n  };\n\n  const handleCopy = async (content: string, section: string) => {\n    try {\n      await navigator.clipboard.writeText(content);\n      setCopiedSection(section);\n      setTimeout(() => setCopiedSection(null), 2000);\n    } catch (error) {\n      console.error('Failed to copy to clipboard:', error);\n    }\n  };\n\n  const formatBytes = (bytes: number): string => {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  const formatTime = (ms: number): string => {\n    if (ms < 1000) return `${ms}ms`;\n    return `${(ms / 1000).toFixed(2)}s`;\n  };\n\n  return (\n    <Box>\n      {/* Status Overview */}\n      <Paper \n        elevation={1} \n        sx={{ \n          p: 2, \n          mb: 2, \n          backgroundColor: 'background.default',\n          border: '1px solid',\n          borderColor: 'divider'\n        }}\n      >\n        <Grid container spacing={2} alignItems=\"center\">\n          <Grid item>\n            <Chip\n              icon={getStatusIcon(response.status)}\n              label={`${response.status} ${response.statusText}`}\n              color={getStatusColor(response.status)}\n              variant=\"filled\"\n            />\n          </Grid>\n          <Grid item>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              Time: {formatTime(response.responseTime)}\n            </Typography>\n          </Grid>\n          <Grid item>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              Size: {formatBytes(response.size)}\n            </Typography>\n          </Grid>\n          <Grid item>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              Type: {response.contentType || 'Unknown'}\n            </Typography>\n          </Grid>\n        </Grid>\n      </Paper>\n\n      {/* Response Headers */}\n      <Accordion \n        sx={{ \n          mb: 2,\n          backgroundColor: 'background.paper',\n          border: '1px solid',\n          borderColor: 'divider',\n          '&:before': { display: 'none' }\n        }}\n      >\n        <AccordionSummary \n          expandIcon={<ExpandMoreIcon />}\n          sx={{ \n            backgroundColor: 'background.default',\n            borderBottom: '1px solid',\n            borderColor: 'divider'\n          }}\n        >\n          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n            <Typography variant=\"subtitle2\">\n              Response Headers ({Object.keys(response.headers).length})\n            </Typography>\n            <Tooltip title=\"Copy headers\">\n              <IconButton\n                size=\"small\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  const headersText = Object.entries(response.headers)\n                    .map(([key, value]) => `${key}: ${value}`)\n                    .join('\\n');\n                  handleCopy(headersText, 'headers');\n                }}\n              >\n                <ContentCopyIcon fontSize=\"small\" />\n              </IconButton>\n            </Tooltip>\n            {copiedSection === 'headers' && (\n              <Typography variant=\"caption\" color=\"success.main\">\n                Copied!\n              </Typography>\n            )}\n          </Box>\n        </AccordionSummary>\n        <AccordionDetails sx={{ p: 0 }}>\n          <Box sx={{ maxHeight: 200, overflow: 'auto' }}>\n            {Object.entries(response.headers).map(([key, value]) => (\n              <Box \n                key={key} \n                sx={{ \n                  p: 1, \n                  borderBottom: '1px solid', \n                  borderColor: 'divider',\n                  '&:last-child': { borderBottom: 'none' }\n                }}\n              >\n                <Grid container spacing={1}>\n                  <Grid item xs={4}>\n                    <Typography \n                      variant=\"body2\" \n                      sx={{ \n                        fontWeight: 'medium',\n                        color: 'text.primary',\n                        wordBreak: 'break-word'\n                      }}\n                    >\n                      {key}:\n                    </Typography>\n                  </Grid>\n                  <Grid item xs={8}>\n                    <Typography \n                      variant=\"body2\" \n                      sx={{ \n                        color: 'text.secondary',\n                        wordBreak: 'break-word'\n                      }}\n                    >\n                      {value}\n                    </Typography>\n                  </Grid>\n                </Grid>\n              </Box>\n            ))}\n          </Box>\n        </AccordionDetails>\n      </Accordion>\n\n      {/* Response Body */}\n      <Paper \n        elevation={1} \n        sx={{ \n          backgroundColor: 'background.paper',\n          border: '1px solid',\n          borderColor: 'divider'\n        }}\n      >\n        <Box \n          sx={{ \n            p: 2, \n            backgroundColor: 'background.default',\n            borderBottom: '1px solid',\n            borderColor: 'divider',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'space-between'\n          }}\n        >\n          <Typography variant=\"subtitle2\">\n            Response Body\n          </Typography>\n          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n            {formatting.isJson && (\n              <Chip label=\"JSON\" size=\"small\" color=\"primary\" variant=\"outlined\" />\n            )}\n            {formatting.isXml && (\n              <Chip label=\"XML\" size=\"small\" color=\"secondary\" variant=\"outlined\" />\n            )}\n            {formatting.isHtml && (\n              <Chip label=\"HTML\" size=\"small\" color=\"info\" variant=\"outlined\" />\n            )}\n            <Tooltip title=\"Copy response body\">\n              <IconButton\n                size=\"small\"\n                onClick={() => handleCopy(response.body, 'body')}\n              >\n                <ContentCopyIcon fontSize=\"small\" />\n              </IconButton>\n            </Tooltip>\n            {copiedSection === 'body' && (\n              <Typography variant=\"caption\" color=\"success.main\">\n                Copied!\n              </Typography>\n            )}\n          </Box>\n        </Box>\n        \n        <Box sx={{ p: 2 }}>\n          {response.body ? (\n            <Box\n              component=\"pre\"\n              sx={{\n                backgroundColor: 'grey.900',\n                color: 'grey.100',\n                p: 2,\n                borderRadius: 1,\n                overflow: 'auto',\n                maxHeight: 400,\n                fontSize: '0.875rem',\n                fontFamily: 'monospace',\n                margin: 0,\n                whiteSpace: 'pre-wrap',\n                wordBreak: 'break-word'\n              }}\n            >\n              {formatting.formatted}\n            </Box>\n          ) : (\n            <Alert severity=\"info\" sx={{ backgroundColor: 'background.default' }}>\n              No response body\n            </Alert>\n          )}\n        </Box>\n      </Paper>\n\n      {/* Response Summary */}\n      <Box sx={{ mt: 2, p: 2, backgroundColor: 'background.default', borderRadius: 1 }}>\n        <Typography variant=\"caption\" color=\"text.secondary\">\n          Response received in {formatTime(response.responseTime)}  \n          {formatBytes(response.size)}  \n          {response.contentType}\n        </Typography>\n      </Box>\n    </Box>\n  );\n};\n","/Users/saptak/code/envddext/ui/src/services/kubectlProxyService.ts",[],[],"/Users/saptak/code/envddext/ui/src/types/gateway.ts",[],[],"/Users/saptak/code/envddext/ui/src/services/portForwardService.ts",["166"],[],"import { v1 } from \"@docker/extension-api-client-types\";\n\nexport interface PortForwardInfo {\n  serviceName: string;\n  namespace: string;\n  servicePort: number;\n  localPort: number;\n  isActive: boolean;\n  pid?: number;\n}\n\nexport class PortForwardService {\n  private ddClient: v1.DockerDesktopClient;\n  private activeForwards: Map<string, PortForwardInfo> = new Map();\n\n  constructor(ddClient: v1.DockerDesktopClient) {\n    this.ddClient = ddClient;\n  }\n\n  /**\n   * Start port forwarding for a service\n   * Note: This is a simplified implementation that assumes port forwarding\n   * For a production implementation, you'd want to use kubectl proxy or similar\n   */\n  async startPortForward(\n    serviceName: string,\n    namespace: string,\n    servicePort: number,\n    localPort?: number\n  ): Promise<PortForwardInfo> {\n    const key = `${namespace}/${serviceName}`;\n\n    // Check if already forwarding\n    if (this.activeForwards.has(key)) {\n      const existing = this.activeForwards.get(key)!;\n      if (existing.isActive) {\n        return existing;\n      }\n    }\n\n    // Use provided local port or find an available one\n    const targetLocalPort = localPort || await this.findAvailablePort();\n\n    try {\n      console.log(`Setting up port forward: ${serviceName}.${namespace}:${servicePort} -> localhost:${targetLocalPort}`);\n\n      // For now, we'll simulate the port forward setup\n      // In a real implementation, you'd start a background process\n      // or use kubectl proxy with proper process management\n\n      const forwardInfo: PortForwardInfo = {\n        serviceName,\n        namespace,\n        servicePort,\n        localPort: targetLocalPort,\n        isActive: true\n      };\n\n      this.activeForwards.set(key, forwardInfo);\n\n      // Log the kubectl command that would be used\n      console.log(`Would run: kubectl port-forward service/${serviceName} ${targetLocalPort}:${servicePort} -n ${namespace}`);\n\n      return forwardInfo;\n\n    } catch (error) {\n      console.error('Failed to start port forward:', error);\n      throw new Error(`Failed to start port forward: ${error}`);\n    }\n  }\n\n  /**\n   * Stop port forwarding for a service\n   */\n  async stopPortForward(serviceName: string, namespace: string): Promise<void> {\n    const key = `${namespace}/${serviceName}`;\n    const forwardInfo = this.activeForwards.get(key);\n\n    if (!forwardInfo) {\n      return;\n    }\n\n    try {\n      // Kill the port-forward process\n      // Note: This is a simplified approach. In a real implementation,\n      // we'd need to track the actual process ID and kill it properly.\n      console.log(`Stopping port forward for ${serviceName}.${namespace}`);\n\n      // Mark as inactive\n      forwardInfo.isActive = false;\n      this.activeForwards.delete(key);\n\n    } catch (error) {\n      console.error('Failed to stop port forward:', error);\n    }\n  }\n\n  /**\n   * Get active port forwards\n   */\n  getActiveForwards(): PortForwardInfo[] {\n    return Array.from(this.activeForwards.values()).filter(f => f.isActive);\n  }\n\n  /**\n   * Get port forward info for a specific service\n   */\n  getPortForward(serviceName: string, namespace: string): PortForwardInfo | undefined {\n    const key = `${namespace}/${serviceName}`;\n    return this.activeForwards.get(key);\n  }\n\n  /**\n   * Find an available local port\n   */\n  private async findAvailablePort(startPort: number = 8080): Promise<number> {\n    // Simple implementation - in a real app, you'd check if ports are actually available\n    const usedPorts = Array.from(this.activeForwards.values()).map(f => f.localPort);\n\n    let port = startPort;\n    while (usedPorts.includes(port)) {\n      port++;\n    }\n\n    return port;\n  }\n\n  /**\n   * Create a localhost URL for a forwarded service\n   */\n  getLocalUrl(serviceName: string, namespace: string, path: string = ''): string | null {\n    const forwardInfo = this.getPortForward(serviceName, namespace);\n    if (!forwardInfo || !forwardInfo.isActive) {\n      return null;\n    }\n\n    const basePath = path.startsWith('/') ? path : `/${path}`;\n    return `http://localhost:${forwardInfo.localPort}${basePath}`;\n  }\n\n  /**\n   * Auto-detect and suggest port forward for a service endpoint\n   */\n  async suggestPortForward(serviceEndpoint: string): Promise<{\n    serviceName: string;\n    namespace: string;\n    port: number;\n    localUrl: string;\n  } | null> {\n    // Parse service endpoint like \"10.244.0.7:8080\"\n    const match = serviceEndpoint.match(/^(\\d+\\.\\d+\\.\\d+\\.\\d+):(\\d+)$/);\n    if (!match) {\n      return null;\n    }\n\n    const [, ip, port] = match;\n    const servicePort = parseInt(port);\n\n    try {\n      // Try to find the service that matches this endpoint\n      const result = await this.ddClient.extension.host?.cli.exec('kubectl', [\n        'get', 'services', '--all-namespaces', '-o', 'json'\n      ]);\n\n      if (result?.stdout) {\n        const services = JSON.parse(result.stdout);\n\n        // Look for a service that might match this endpoint\n        for (const service of services.items) {\n          const serviceName = service.metadata.name;\n          const namespace = service.metadata.namespace;\n\n          // Check if this service has a port that matches\n          if (service.spec.ports) {\n            for (const portSpec of service.spec.ports) {\n              if (portSpec.port === servicePort || portSpec.targetPort === servicePort) {\n                // Found a potential match\n                const localPort = await this.findAvailablePort();\n                return {\n                  serviceName,\n                  namespace,\n                  port: servicePort,\n                  localUrl: `http://localhost:${localPort}`\n                };\n              }\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Failed to suggest port forward:', error);\n    }\n\n    return null;\n  }\n}\n","/Users/saptak/code/envddext/ui/src/services/loadBalancerService.ts",[],[],"/Users/saptak/code/envddext/ui/src/utils/gatewayValidation.ts",[],[],{"ruleId":"167","severity":1,"message":"168","line":4,"column":8,"nodeType":"169","messageId":"170","endLine":4,"endColumn":12},{"ruleId":"167","severity":1,"message":"171","line":14,"column":3,"nodeType":"169","messageId":"170","endLine":14,"endColumn":7},{"ruleId":"167","severity":1,"message":"172","line":15,"column":3,"nodeType":"169","messageId":"170","endLine":15,"endColumn":11},{"ruleId":"167","severity":1,"message":"173","line":16,"column":3,"nodeType":"169","messageId":"170","endLine":16,"endColumn":15},{"ruleId":"167","severity":1,"message":"174","line":17,"column":3,"nodeType":"169","messageId":"170","endLine":17,"endColumn":15},{"ruleId":"175","severity":1,"message":"176","line":112,"column":6,"nodeType":"177","endLine":112,"endColumn":16,"suggestions":"178"},{"ruleId":"167","severity":1,"message":"179","line":187,"column":13,"nodeType":"169","messageId":"170","endLine":187,"endColumn":29},{"ruleId":"167","severity":1,"message":"180","line":10,"column":3,"nodeType":"169","messageId":"170","endLine":10,"endColumn":16},{"ruleId":"167","severity":1,"message":"181","line":13,"column":3,"nodeType":"169","messageId":"170","endLine":13,"endColumn":10},{"ruleId":"167","severity":1,"message":"182","line":14,"column":3,"nodeType":"169","messageId":"170","endLine":14,"endColumn":7},{"ruleId":"175","severity":1,"message":"183","line":97,"column":6,"nodeType":"177","endLine":97,"endColumn":76,"suggestions":"184"},{"ruleId":"167","severity":1,"message":"181","line":17,"column":3,"nodeType":"169","messageId":"170","endLine":17,"endColumn":10},{"ruleId":"167","severity":1,"message":"185","line":23,"column":8,"nodeType":"169","messageId":"170","endLine":23,"endColumn":19},{"ruleId":"167","severity":1,"message":"186","line":98,"column":9,"nodeType":"169","messageId":"170","endLine":98,"endColumn":25},{"ruleId":"167","severity":1,"message":"187","line":102,"column":9,"nodeType":"169","messageId":"170","endLine":102,"endColumn":27},{"ruleId":"167","severity":1,"message":"188","line":111,"column":9,"nodeType":"169","messageId":"170","endLine":111,"endColumn":18},{"ruleId":"167","severity":1,"message":"189","line":118,"column":9,"nodeType":"169","messageId":"170","endLine":118,"endColumn":21},{"ruleId":"167","severity":1,"message":"190","line":12,"column":3,"nodeType":"169","messageId":"170","endLine":12,"endColumn":14},{"ruleId":"167","severity":1,"message":"191","line":13,"column":3,"nodeType":"169","messageId":"170","endLine":13,"endColumn":13},{"ruleId":"167","severity":1,"message":"192","line":14,"column":3,"nodeType":"169","messageId":"170","endLine":14,"endColumn":9},{"ruleId":"167","severity":1,"message":"193","line":15,"column":3,"nodeType":"169","messageId":"170","endLine":15,"endColumn":11},{"ruleId":"175","severity":1,"message":"194","line":66,"column":6,"nodeType":"177","endLine":66,"endColumn":20,"suggestions":"195"},{"ruleId":"175","severity":1,"message":"196","line":153,"column":6,"nodeType":"177","endLine":153,"endColumn":65,"suggestions":"197"},{"ruleId":"175","severity":1,"message":"194","line":62,"column":6,"nodeType":"177","endLine":62,"endColumn":8,"suggestions":"198"},{"ruleId":"167","severity":1,"message":"199","line":5,"column":3,"nodeType":"169","messageId":"170","endLine":5,"endColumn":8},{"ruleId":"167","severity":1,"message":"200","line":19,"column":8,"nodeType":"169","messageId":"170","endLine":19,"endColumn":21},{"ruleId":"175","severity":1,"message":"201","line":63,"column":6,"nodeType":"177","endLine":63,"endColumn":60,"suggestions":"202"},{"ruleId":"167","severity":1,"message":"203","line":22,"column":8,"nodeType":"169","messageId":"170","endLine":22,"endColumn":18},{"ruleId":"167","severity":1,"message":"204","line":16,"column":8,"nodeType":"169","messageId":"170","endLine":16,"endColumn":18},{"ruleId":"167","severity":1,"message":"181","line":13,"column":3,"nodeType":"169","messageId":"170","endLine":13,"endColumn":10},{"ruleId":"167","severity":1,"message":"205","line":156,"column":14,"nodeType":"169","messageId":"170","endLine":156,"endColumn":16},"@typescript-eslint/no-unused-vars","'yaml' is defined but never used.","Identifier","unusedVar","'List' is defined but never used.","'ListItem' is defined but never used.","'ListItemText' is defined but never used.","'ListItemIcon' is defined but never used.","react-hooks/exhaustive-deps","React Hook React.useCallback has an unnecessary dependency: 'ddClient'. Either exclude it or remove the dependency array. Outer scope values like 'ddClient' aren't valid dependencies because mutating them doesn't re-render the component.","ArrayExpression",["206"],"'gatewayClassYaml' is assigned a value but never used.","'DialogActions' is defined but never used.","'Divider' is defined but never used.","'Chip' is defined but never used.","React Hook useEffect has missing dependencies: 'fetchStatus' and 'refreshTimer'. Either include them or remove the dependency array.",["207"],"'HistoryIcon' is defined but never used.","'handleBodyChange' is assigned a value but never used.","'handleHeaderChange' is assigned a value but never used.","'addHeader' is assigned a value but never used.","'removeHeader' is assigned a value but never used.","'FormControl' is defined but never used.","'InputLabel' is defined but never used.","'Select' is defined but never used.","'MenuItem' is defined but never used.","React Hook useEffect has a missing dependency: 'checkStatus'. Either include it or remove the dependency array.",["208"],"React Hook useEffect has a missing dependency: 'updateGeneratedUrl'. Either include it or remove the dependency array.",["209"],["210"],"'Paper' is defined but never used.","'BugReportIcon' is defined but never used.","React Hook useEffect has a missing dependency: 'fetchGatewayStatus'. Either include it or remove the dependency array.",["211"],"'DeleteIcon' is defined but never used.","'LaunchIcon' is defined but never used.","'ip' is assigned a value but never used.",{"desc":"212","fix":"213"},{"desc":"214","fix":"215"},{"desc":"216","fix":"217"},{"desc":"218","fix":"219"},{"desc":"220","fix":"221"},{"desc":"222","fix":"223"},"Update the dependencies array to be: []",{"range":"224","text":"225"},"Update the dependencies array to be: [namespace, deploymentName, serviceName, autoRefresh, refreshInterval, fetchStatus, refreshTimer]",{"range":"226","text":"227"},"Update the dependencies array to be: [checkStatus, proxyService]",{"range":"228","text":"229"},"Update the dependencies array to be: [serviceName, namespace, port, path, proxyStatus.isRunning, updateGeneratedUrl]",{"range":"230","text":"231"},"Update the dependencies array to be: [checkStatus]",{"range":"232","text":"233"},"Update the dependencies array to be: [gatewayName, namespace, autoRefresh, refreshInterval, fetchGatewayStatus]",{"range":"234","text":"235"},[3878,3888],"[]",[3000,3070],"[namespace, deploymentName, serviceName, autoRefresh, refreshInterval, fetchStatus, refreshTimer]",[1971,1985],"[checkStatus, proxyService]",[4347,4406],"[serviceName, namespace, port, path, proxyStatus.isRunning, updateGeneratedUrl]",[1623,1625],"[checkStatus]",[1934,1988],"[gatewayName, namespace, autoRefresh, refreshInterval, fetchGatewayStatus]"]